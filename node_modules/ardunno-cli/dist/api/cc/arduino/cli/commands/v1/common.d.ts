import _m0 from 'protobufjs/minimal';
export interface Instance {
    /** The ID of the instance. */
    id: number;
}
export interface DownloadProgress {
    message?: {
        $case: 'start';
        start: DownloadProgressStart;
    } | {
        $case: 'update';
        update: DownloadProgressUpdate;
    } | {
        $case: 'end';
        end: DownloadProgressEnd;
    } | undefined;
}
export interface DownloadProgressStart {
    /** URL of the download. */
    url: string;
    /** The label to display on the progress bar. */
    label: string;
}
export interface DownloadProgressUpdate {
    /** Size of the downloaded portion of the file. */
    downloaded: number;
    /** Total size of the file being downloaded. */
    totalSize: number;
}
export interface DownloadProgressEnd {
    /** True if the download is successful */
    success: boolean;
    /**
     * Info or error message, depending on the value of 'success'. Some examples:
     * "File xxx already downloaded" or "Connection timeout"
     */
    message: string;
}
export interface TaskProgress {
    /** Description of the task. */
    name: string;
    /** Additional information about the task. */
    message: string;
    /** Whether the task is complete. */
    completed: boolean;
    /** Amount in percent of the task completion (optional) */
    percent: number;
}
export interface Programmer {
    /** Platform name */
    platform: string;
    /** Programmer ID */
    id: string;
    /** Programmer name */
    name: string;
}
/**
 * MissingProgrammerError is a status error detail that is returned when
 * the operation can not be completed due to a missing programmer argument.
 */
export interface MissingProgrammerError {
}
export interface Platform {
    /** Platform ID (e.g., `arduino:avr`). */
    id: string;
    /** Version of the platform. */
    installed: string;
    /** Newest available version of the platform. */
    latest: string;
    /** Name used to identify the platform to humans (e.g., "Arduino AVR Boards"). */
    name: string;
    /** Maintainer of the platform's package. */
    maintainer: string;
    /**
     * A URL provided by the author of the platform's package, intended to point
     * to their website.
     */
    website: string;
    /** Email of the maintainer of the platform's package. */
    email: string;
    /**
     * List of boards provided by the platform. If the platform is installed,
     * this is the boards listed in the platform's boards.txt. If the platform is
     * not installed, this is an arbitrary list of board names provided by the
     * platform author for display and may not match boards.txt.
     */
    boards: Board[];
    /**
     * If true this Platform has been installed manually in the user' sketchbook
     * hardware folder
     */
    manuallyInstalled: boolean;
    /** If true this Platform has been deprecated */
    deprecated: boolean;
    /** Type of the platform. */
    type: string[];
    /**
     * A URL provided by the author of the platform's package, intended to point
     * to their online help service.
     */
    help: HelpResources | undefined;
    /** If true the platform is indexed */
    indexed: boolean;
    /**
     * This field is true when the platform is installed with the Arduino IDE 1.8.
     * If the platform is also not indexed it may fail to work correctly in some
     * circumstances, and it may need to be re-installed.
     */
    missingMetadata: boolean;
}
export interface InstalledPlatformReference {
    /** Platform ID (e.g., `arduino:avr`). */
    id: string;
    /** Version of the platform. */
    version: string;
    /** Installation directory of the platform */
    installDir: string;
    /** 3rd party platform URL */
    packageUrl: string;
}
export interface Board {
    /** Name used to identify the board to humans. */
    name: string;
    /**
     * Fully qualified board name used to identify the board to machines. The FQBN
     * is only available for installed boards.
     */
    fqbn: string;
}
export interface Profile {
    /** Name used to identify the profile within the sketch. */
    name: string;
    /** FQBN specified in the profile. */
    fqbn: string;
}
export interface HelpResources {
    /**
     * A URL provided by the author of the platform's package, intended to point
     * to their online help service.
     */
    online: string;
}
export declare const Instance: {
    encode(message: Instance, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Instance;
    fromJSON(object: any): Instance;
    toJSON(message: Instance): unknown;
    create(base?: DeepPartial<Instance>): Instance;
    fromPartial(object: DeepPartial<Instance>): Instance;
};
export declare const DownloadProgress: {
    encode(message: DownloadProgress, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DownloadProgress;
    fromJSON(object: any): DownloadProgress;
    toJSON(message: DownloadProgress): unknown;
    create(base?: DeepPartial<DownloadProgress>): DownloadProgress;
    fromPartial(object: DeepPartial<DownloadProgress>): DownloadProgress;
};
export declare const DownloadProgressStart: {
    encode(message: DownloadProgressStart, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DownloadProgressStart;
    fromJSON(object: any): DownloadProgressStart;
    toJSON(message: DownloadProgressStart): unknown;
    create(base?: DeepPartial<DownloadProgressStart>): DownloadProgressStart;
    fromPartial(object: DeepPartial<DownloadProgressStart>): DownloadProgressStart;
};
export declare const DownloadProgressUpdate: {
    encode(message: DownloadProgressUpdate, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DownloadProgressUpdate;
    fromJSON(object: any): DownloadProgressUpdate;
    toJSON(message: DownloadProgressUpdate): unknown;
    create(base?: DeepPartial<DownloadProgressUpdate>): DownloadProgressUpdate;
    fromPartial(object: DeepPartial<DownloadProgressUpdate>): DownloadProgressUpdate;
};
export declare const DownloadProgressEnd: {
    encode(message: DownloadProgressEnd, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DownloadProgressEnd;
    fromJSON(object: any): DownloadProgressEnd;
    toJSON(message: DownloadProgressEnd): unknown;
    create(base?: DeepPartial<DownloadProgressEnd>): DownloadProgressEnd;
    fromPartial(object: DeepPartial<DownloadProgressEnd>): DownloadProgressEnd;
};
export declare const TaskProgress: {
    encode(message: TaskProgress, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TaskProgress;
    fromJSON(object: any): TaskProgress;
    toJSON(message: TaskProgress): unknown;
    create(base?: DeepPartial<TaskProgress>): TaskProgress;
    fromPartial(object: DeepPartial<TaskProgress>): TaskProgress;
};
export declare const Programmer: {
    encode(message: Programmer, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Programmer;
    fromJSON(object: any): Programmer;
    toJSON(message: Programmer): unknown;
    create(base?: DeepPartial<Programmer>): Programmer;
    fromPartial(object: DeepPartial<Programmer>): Programmer;
};
export declare const MissingProgrammerError: {
    encode(_: MissingProgrammerError, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MissingProgrammerError;
    fromJSON(_: any): MissingProgrammerError;
    toJSON(_: MissingProgrammerError): unknown;
    create(base?: DeepPartial<MissingProgrammerError>): MissingProgrammerError;
    fromPartial(_: DeepPartial<MissingProgrammerError>): MissingProgrammerError;
};
export declare const Platform: {
    encode(message: Platform, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Platform;
    fromJSON(object: any): Platform;
    toJSON(message: Platform): unknown;
    create(base?: DeepPartial<Platform>): Platform;
    fromPartial(object: DeepPartial<Platform>): Platform;
};
export declare const InstalledPlatformReference: {
    encode(message: InstalledPlatformReference, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InstalledPlatformReference;
    fromJSON(object: any): InstalledPlatformReference;
    toJSON(message: InstalledPlatformReference): unknown;
    create(base?: DeepPartial<InstalledPlatformReference>): InstalledPlatformReference;
    fromPartial(object: DeepPartial<InstalledPlatformReference>): InstalledPlatformReference;
};
export declare const Board: {
    encode(message: Board, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Board;
    fromJSON(object: any): Board;
    toJSON(message: Board): unknown;
    create(base?: DeepPartial<Board>): Board;
    fromPartial(object: DeepPartial<Board>): Board;
};
export declare const Profile: {
    encode(message: Profile, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Profile;
    fromJSON(object: any): Profile;
    toJSON(message: Profile): unknown;
    create(base?: DeepPartial<Profile>): Profile;
    fromPartial(object: DeepPartial<Profile>): Profile;
};
export declare const HelpResources: {
    encode(message: HelpResources, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): HelpResources;
    fromJSON(object: any): HelpResources;
    toJSON(message: HelpResources): unknown;
    create(base?: DeepPartial<HelpResources>): HelpResources;
    fromPartial(object: DeepPartial<HelpResources>): HelpResources;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, '$case'>]?: DeepPartial<T[K]>;
} & {
    $case: T['$case'];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=common.d.ts.map