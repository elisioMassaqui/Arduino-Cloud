import _m0 from 'protobufjs/minimal';
import { DownloadProgress, Instance, Platform, TaskProgress } from './common';
export interface PlatformInstallRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /** Vendor name of the platform (e.g., `arduino`). */
    platformPackage: string;
    /** Architecture name of the platform (e.g., `avr`). */
    architecture: string;
    /** Platform version to install. */
    version: string;
    /**
     * Set to true to not run (eventual) post install scripts for trusted
     * platforms
     */
    skipPostInstall: boolean;
    /**
     * Set to true to skip installation if a different version of the platform
     * is already installed.
     */
    noOverwrite: boolean;
    /**
     * Set to true to not run (eventual) pre uninstall scripts for trusted
     * platforms when performing platform upgrades
     */
    skipPreUninstall: boolean;
}
export interface PlatformInstallResponse {
    /** Progress of the downloads of the platform and tool files. */
    progress: DownloadProgress | undefined;
    /** Description of the current stage of the installation. */
    taskProgress: TaskProgress | undefined;
}
export interface PlatformLoadingError {
}
export interface PlatformDownloadRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    platformPackage: string;
    /** Architecture name of the platform (e.g., `avr`). */
    architecture: string;
    /** Platform version to download. */
    version: string;
}
export interface PlatformDownloadResponse {
    /** Progress of the downloads of platform and tool files. */
    progress: DownloadProgress | undefined;
}
export interface PlatformUninstallRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /** Vendor name of the platform (e.g., `arduino`). */
    platformPackage: string;
    /** Architecture name of the platform (e.g., `avr`). */
    architecture: string;
    /**
     * Set to true to not run (eventual) pre uninstall scripts for trusted
     * platforms
     */
    skipPreUninstall: boolean;
}
export interface PlatformUninstallResponse {
    /** Description of the current stage of the uninstall. */
    taskProgress: TaskProgress | undefined;
}
/**
 * AlreadyAtLatestVersionError is returned when an upgrade is not possible
 * because already at latest version.
 */
export interface AlreadyAtLatestVersionError {
}
export interface PlatformUpgradeRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /** Vendor name of the platform (e.g., `arduino`). */
    platformPackage: string;
    /** Architecture name of the platform (e.g., `avr`). */
    architecture: string;
    /**
     * Set to true to not run (eventual) post install scripts for trusted
     * platforms
     */
    skipPostInstall: boolean;
    /**
     * Set to true to not run (eventual) pre uninstall scripts for trusted
     * platforms when performing platform upgrades
     */
    skipPreUninstall: boolean;
}
export interface PlatformUpgradeResponse {
    /** Progress of the downloads of the platform and tool files. */
    progress: DownloadProgress | undefined;
    /** Description of the current stage of the upgrade. */
    taskProgress: TaskProgress | undefined;
    /** The upgraded platform. */
    platform: Platform | undefined;
}
export interface PlatformSearchRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /** Keywords for the search. */
    searchArgs: string;
    /**
     * Whether to show all available versions. `false` causes only the newest
     * versions of the cores to be listed in the search results.
     */
    allVersions: boolean;
}
export interface PlatformSearchResponse {
    /** Results of the search. */
    searchOutput: Platform[];
}
export interface PlatformListRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /**
     * Set to true to only list platforms which have a newer version available
     * than the one currently installed.
     */
    updatableOnly: boolean;
    /**
     * Set to true to list platforms installed manually in the user' sketchbook
     * hardware folder, installed with the PlatformManager through the CLI or
     * IDE and that are available to install
     */
    all: boolean;
}
export interface PlatformListResponse {
    /** The installed platforms. */
    installedPlatforms: Platform[];
}
export declare const PlatformInstallRequest: {
    encode(message: PlatformInstallRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformInstallRequest;
    fromJSON(object: any): PlatformInstallRequest;
    toJSON(message: PlatformInstallRequest): unknown;
    create(base?: DeepPartial<PlatformInstallRequest>): PlatformInstallRequest;
    fromPartial(object: DeepPartial<PlatformInstallRequest>): PlatformInstallRequest;
};
export declare const PlatformInstallResponse: {
    encode(message: PlatformInstallResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformInstallResponse;
    fromJSON(object: any): PlatformInstallResponse;
    toJSON(message: PlatformInstallResponse): unknown;
    create(base?: DeepPartial<PlatformInstallResponse>): PlatformInstallResponse;
    fromPartial(object: DeepPartial<PlatformInstallResponse>): PlatformInstallResponse;
};
export declare const PlatformLoadingError: {
    encode(_: PlatformLoadingError, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformLoadingError;
    fromJSON(_: any): PlatformLoadingError;
    toJSON(_: PlatformLoadingError): unknown;
    create(base?: DeepPartial<PlatformLoadingError>): PlatformLoadingError;
    fromPartial(_: DeepPartial<PlatformLoadingError>): PlatformLoadingError;
};
export declare const PlatformDownloadRequest: {
    encode(message: PlatformDownloadRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformDownloadRequest;
    fromJSON(object: any): PlatformDownloadRequest;
    toJSON(message: PlatformDownloadRequest): unknown;
    create(base?: DeepPartial<PlatformDownloadRequest>): PlatformDownloadRequest;
    fromPartial(object: DeepPartial<PlatformDownloadRequest>): PlatformDownloadRequest;
};
export declare const PlatformDownloadResponse: {
    encode(message: PlatformDownloadResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformDownloadResponse;
    fromJSON(object: any): PlatformDownloadResponse;
    toJSON(message: PlatformDownloadResponse): unknown;
    create(base?: DeepPartial<PlatformDownloadResponse>): PlatformDownloadResponse;
    fromPartial(object: DeepPartial<PlatformDownloadResponse>): PlatformDownloadResponse;
};
export declare const PlatformUninstallRequest: {
    encode(message: PlatformUninstallRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformUninstallRequest;
    fromJSON(object: any): PlatformUninstallRequest;
    toJSON(message: PlatformUninstallRequest): unknown;
    create(base?: DeepPartial<PlatformUninstallRequest>): PlatformUninstallRequest;
    fromPartial(object: DeepPartial<PlatformUninstallRequest>): PlatformUninstallRequest;
};
export declare const PlatformUninstallResponse: {
    encode(message: PlatformUninstallResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformUninstallResponse;
    fromJSON(object: any): PlatformUninstallResponse;
    toJSON(message: PlatformUninstallResponse): unknown;
    create(base?: DeepPartial<PlatformUninstallResponse>): PlatformUninstallResponse;
    fromPartial(object: DeepPartial<PlatformUninstallResponse>): PlatformUninstallResponse;
};
export declare const AlreadyAtLatestVersionError: {
    encode(_: AlreadyAtLatestVersionError, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AlreadyAtLatestVersionError;
    fromJSON(_: any): AlreadyAtLatestVersionError;
    toJSON(_: AlreadyAtLatestVersionError): unknown;
    create(base?: DeepPartial<AlreadyAtLatestVersionError>): AlreadyAtLatestVersionError;
    fromPartial(_: DeepPartial<AlreadyAtLatestVersionError>): AlreadyAtLatestVersionError;
};
export declare const PlatformUpgradeRequest: {
    encode(message: PlatformUpgradeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformUpgradeRequest;
    fromJSON(object: any): PlatformUpgradeRequest;
    toJSON(message: PlatformUpgradeRequest): unknown;
    create(base?: DeepPartial<PlatformUpgradeRequest>): PlatformUpgradeRequest;
    fromPartial(object: DeepPartial<PlatformUpgradeRequest>): PlatformUpgradeRequest;
};
export declare const PlatformUpgradeResponse: {
    encode(message: PlatformUpgradeResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformUpgradeResponse;
    fromJSON(object: any): PlatformUpgradeResponse;
    toJSON(message: PlatformUpgradeResponse): unknown;
    create(base?: DeepPartial<PlatformUpgradeResponse>): PlatformUpgradeResponse;
    fromPartial(object: DeepPartial<PlatformUpgradeResponse>): PlatformUpgradeResponse;
};
export declare const PlatformSearchRequest: {
    encode(message: PlatformSearchRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformSearchRequest;
    fromJSON(object: any): PlatformSearchRequest;
    toJSON(message: PlatformSearchRequest): unknown;
    create(base?: DeepPartial<PlatformSearchRequest>): PlatformSearchRequest;
    fromPartial(object: DeepPartial<PlatformSearchRequest>): PlatformSearchRequest;
};
export declare const PlatformSearchResponse: {
    encode(message: PlatformSearchResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformSearchResponse;
    fromJSON(object: any): PlatformSearchResponse;
    toJSON(message: PlatformSearchResponse): unknown;
    create(base?: DeepPartial<PlatformSearchResponse>): PlatformSearchResponse;
    fromPartial(object: DeepPartial<PlatformSearchResponse>): PlatformSearchResponse;
};
export declare const PlatformListRequest: {
    encode(message: PlatformListRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformListRequest;
    fromJSON(object: any): PlatformListRequest;
    toJSON(message: PlatformListRequest): unknown;
    create(base?: DeepPartial<PlatformListRequest>): PlatformListRequest;
    fromPartial(object: DeepPartial<PlatformListRequest>): PlatformListRequest;
};
export declare const PlatformListResponse: {
    encode(message: PlatformListResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PlatformListResponse;
    fromJSON(object: any): PlatformListResponse;
    toJSON(message: PlatformListResponse): unknown;
    create(base?: DeepPartial<PlatformListResponse>): PlatformListResponse;
    fromPartial(object: DeepPartial<PlatformListResponse>): PlatformListResponse;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, '$case'>]?: DeepPartial<T[K]>;
} & {
    $case: T['$case'];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=core.d.ts.map