import _m0 from 'protobufjs/minimal';
import { Any } from '../../../../../google/protobuf/any';
import { Instance } from './common';
import { Port } from './port';
/**
 * The top-level message sent by the client for the `Debug` method.
 * Multiple `DebugRequest` messages can be sent but the first message
 * must contain a `GetDebugConfigRequest` message to initialize the debug
 * session. All subsequent messages must contain bytes to be sent to the debug
 * session and must not contain a `GetDebugConfigRequest` message.
 */
export interface DebugRequest {
    /**
     * Provides information to the debug that specifies which is the target.
     * The first `DebugRequest` message must contain a `GetDebugConfigRequest`
     * message.
     */
    debugRequest: GetDebugConfigRequest | undefined;
    /** The data to be sent to the target being monitored. */
    data: Uint8Array;
    /** Set this to true to send and Interrupt signal to the debugger process */
    sendInterrupt: boolean;
}
/**
 * The streaming response may contain chunks of data from the debugger or an
 * error.
 */
export interface DebugResponse {
    /** Incoming data from the debugger tool. */
    data: Uint8Array;
    /** Incoming error output from the debugger tool. */
    error: string;
}
export interface IsDebugSupportedRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /**
     * Fully qualified board name of the board in use (e.g.,
     * `arduino:samd:mkr1000`).
     */
    fqbn: string;
    /** Port of the debugger (optional). */
    port: Port | undefined;
    /** Which GDB command interpreter to use. */
    interpreter: string;
    /** The programmer to use for debugging. */
    programmer: string;
}
export interface IsDebugSupportedResponse {
    /** True if debugging is supported */
    debuggingSupported: boolean;
    /**
     * This is the same FQBN given in the IsDebugSupportedRequest but cleaned
     * up of the board options that do not affect the debugger configuration.
     * It may be used by clients/IDE to group slightly different boards option
     * selections under the same debug configuration.
     */
    debugFqbn: string;
}
export interface GetDebugConfigRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /**
     * Fully qualified board name of the board in use
     * (e.g., `arduino:samd:mkr1000`). If this is omitted, the FQBN attached to
     * the sketch will be used.
     */
    fqbn: string;
    /**
     * Path to the sketch that is running on the board. The compiled executable
     * is expected to be located under this path.
     */
    sketchPath: string;
    /** Port of the debugger (optional). */
    port: Port | undefined;
    /** Which GDB command interpreter to use. */
    interpreter: string;
    /**
     * Directory containing the compiled executable. If `import_dir` is not
     * specified, the executable is assumed to be in
     * `{sketch_path}/build/{fqbn}/`.
     */
    importDir: string;
    /** The programmer to use for debugging. */
    programmer: string;
}
export interface GetDebugConfigResponse {
    /** The executable binary to debug */
    executable: string;
    /** The toolchain type used for the build (for example "gcc") */
    toolchain: string;
    /** The toolchain directory */
    toolchainPath: string;
    /** The toolchain architecture prefix (for example "arm-none-eabi") */
    toolchainPrefix: string;
    /**
     * The GDB server type used to connect to the programmer/board (for example
     * "openocd")
     */
    server: string;
    /** The GDB server directory */
    serverPath: string;
    /** Extra configuration parameters wrt toolchain */
    toolchainConfiguration: Any | undefined;
    /** Extra configuration parameters wrt GDB server */
    serverConfiguration: Any | undefined;
    /**
     * Custom debugger configurations (not handled directly by Arduino CLI but
     * provided for 3rd party plugins/debuggers). The map keys identifies which
     * 3rd party plugin/debugger is referred, the map string values contains a
     * JSON configuration for it.
     */
    customConfigs: {
        [key: string]: string;
    };
    /** the SVD file to use */
    svdFile: string;
    /** The programmer specified in the request */
    programmer: string;
}
export interface GetDebugConfigResponse_CustomConfigsEntry {
    key: string;
    value: string;
}
/** Configurations specific for the 'gcc' toolchain */
export interface DebugGCCToolchainConfiguration {
}
/** Configuration specific for the 'openocd` server */
export interface DebugOpenOCDServerConfiguration {
    /** path to openocd */
    path: string;
    /** path to openocd scripts */
    scriptsDir: string;
    /** list of scripts to execute by openocd */
    scripts: string[];
}
export declare const DebugRequest: {
    encode(message: DebugRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DebugRequest;
    fromJSON(object: any): DebugRequest;
    toJSON(message: DebugRequest): unknown;
    create(base?: DeepPartial<DebugRequest>): DebugRequest;
    fromPartial(object: DeepPartial<DebugRequest>): DebugRequest;
};
export declare const DebugResponse: {
    encode(message: DebugResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DebugResponse;
    fromJSON(object: any): DebugResponse;
    toJSON(message: DebugResponse): unknown;
    create(base?: DeepPartial<DebugResponse>): DebugResponse;
    fromPartial(object: DeepPartial<DebugResponse>): DebugResponse;
};
export declare const IsDebugSupportedRequest: {
    encode(message: IsDebugSupportedRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): IsDebugSupportedRequest;
    fromJSON(object: any): IsDebugSupportedRequest;
    toJSON(message: IsDebugSupportedRequest): unknown;
    create(base?: DeepPartial<IsDebugSupportedRequest>): IsDebugSupportedRequest;
    fromPartial(object: DeepPartial<IsDebugSupportedRequest>): IsDebugSupportedRequest;
};
export declare const IsDebugSupportedResponse: {
    encode(message: IsDebugSupportedResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): IsDebugSupportedResponse;
    fromJSON(object: any): IsDebugSupportedResponse;
    toJSON(message: IsDebugSupportedResponse): unknown;
    create(base?: DeepPartial<IsDebugSupportedResponse>): IsDebugSupportedResponse;
    fromPartial(object: DeepPartial<IsDebugSupportedResponse>): IsDebugSupportedResponse;
};
export declare const GetDebugConfigRequest: {
    encode(message: GetDebugConfigRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetDebugConfigRequest;
    fromJSON(object: any): GetDebugConfigRequest;
    toJSON(message: GetDebugConfigRequest): unknown;
    create(base?: DeepPartial<GetDebugConfigRequest>): GetDebugConfigRequest;
    fromPartial(object: DeepPartial<GetDebugConfigRequest>): GetDebugConfigRequest;
};
export declare const GetDebugConfigResponse: {
    encode(message: GetDebugConfigResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetDebugConfigResponse;
    fromJSON(object: any): GetDebugConfigResponse;
    toJSON(message: GetDebugConfigResponse): unknown;
    create(base?: DeepPartial<GetDebugConfigResponse>): GetDebugConfigResponse;
    fromPartial(object: DeepPartial<GetDebugConfigResponse>): GetDebugConfigResponse;
};
export declare const GetDebugConfigResponse_CustomConfigsEntry: {
    encode(message: GetDebugConfigResponse_CustomConfigsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetDebugConfigResponse_CustomConfigsEntry;
    fromJSON(object: any): GetDebugConfigResponse_CustomConfigsEntry;
    toJSON(message: GetDebugConfigResponse_CustomConfigsEntry): unknown;
    create(base?: DeepPartial<GetDebugConfigResponse_CustomConfigsEntry>): GetDebugConfigResponse_CustomConfigsEntry;
    fromPartial(object: DeepPartial<GetDebugConfigResponse_CustomConfigsEntry>): GetDebugConfigResponse_CustomConfigsEntry;
};
export declare const DebugGCCToolchainConfiguration: {
    encode(_: DebugGCCToolchainConfiguration, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DebugGCCToolchainConfiguration;
    fromJSON(_: any): DebugGCCToolchainConfiguration;
    toJSON(_: DebugGCCToolchainConfiguration): unknown;
    create(base?: DeepPartial<DebugGCCToolchainConfiguration>): DebugGCCToolchainConfiguration;
    fromPartial(_: DeepPartial<DebugGCCToolchainConfiguration>): DebugGCCToolchainConfiguration;
};
export declare const DebugOpenOCDServerConfiguration: {
    encode(message: DebugOpenOCDServerConfiguration, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DebugOpenOCDServerConfiguration;
    fromJSON(object: any): DebugOpenOCDServerConfiguration;
    toJSON(message: DebugOpenOCDServerConfiguration): unknown;
    create(base?: DeepPartial<DebugOpenOCDServerConfiguration>): DebugOpenOCDServerConfiguration;
    fromPartial(object: DeepPartial<DebugOpenOCDServerConfiguration>): DebugOpenOCDServerConfiguration;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, '$case'>]?: DeepPartial<T[K]>;
} & {
    $case: T['$case'];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=debug.d.ts.map