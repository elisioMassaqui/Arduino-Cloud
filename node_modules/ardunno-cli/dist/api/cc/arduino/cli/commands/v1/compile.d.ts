import _m0 from 'protobufjs/minimal';
import { InstalledPlatformReference, Instance, TaskProgress } from './common';
import { Library } from './lib';
export interface CompileRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /**
     * Fully Qualified Board Name, e.g.: `arduino:avr:uno`. If this field is
     * not defined, the FQBN of the board attached to the sketch via the
     * `BoardAttach` method is used.
     */
    fqbn: string;
    /** The path where the sketch is stored. */
    sketchPath: string;
    /** Just get the build properties and do not run the full compile. */
    showProperties: boolean;
    /** Print preprocessed code to stdout instead of compiling. */
    preprocess: boolean;
    /** Builds of 'core.a' are saved into this path to be cached and reused. */
    buildCachePath: string;
    /**
     * Path to use to store the files used for the compilation. If omitted,
     * a directory will be created in the operating system's default temporary
     * path.
     */
    buildPath: string;
    /** List of custom build properties separated by commas. */
    buildProperties: string[];
    /**
     * Used to tell gcc which warning level to use. The level names are: "none",
     * "default", "more" and "all".
     */
    warnings: string;
    /** Turns on verbose mode. */
    verbose: boolean;
    /** Suppresses almost every output. */
    quiet: boolean;
    /**
     * The max number of concurrent compiler instances to run (as `make -jx`).
     * If jobs is set to 0, it will use the number of available CPUs as the
     * maximum.
     */
    jobs: number;
    /** A list of paths to directories containing a collection of libraries. */
    libraries: string[];
    /** Optimize compile output for debug, not for release. */
    optimizeForDebug: boolean;
    /**
     * Optional: save the build artifacts in this directory, the directory must
     * exist.
     */
    exportDir: string;
    /**
     * Optional: cleanup the build folder and do not use any previously cached
     * build
     */
    clean: boolean;
    /**
     * When set to `true` only the compilation database will be produced and no
     * actual build will be performed.
     */
    createCompilationDatabaseOnly: boolean;
    /**
     * This map (source file -> new content) let the builder use the provided
     * content instead of reading the corresponding file on disk. This is useful
     * for IDE that have unsaved changes in memory. The path must be relative to
     * the sketch directory. Only files from the sketch are allowed.
     */
    sourceOverride: {
        [key: string]: string;
    };
    /**
     * When set to `true` the compiled binary will be copied to the export
     * directory.
     */
    exportBinaries: boolean | undefined;
    /** A list of paths to single libraries root directory. */
    library: string[];
    /**
     * The path where to search for the custom signing key name and the encrypt
     * key name
     */
    keysKeychain: string;
    /** The name of the custom key to use for signing during the compile process */
    signKey: string;
    /** The name of the custom key to use for encrypting during the compile process */
    encryptKey: string;
    /**
     * If set to true the build will skip the library discovery process and will
     * use the same libraries of latest build. Enabling this flag may produce a
     * wrong output and should not be used in regular compiles unless there is a
     * very specific reason to do so. This flag is mainly provided for usage in
     * language servers to optimize the build speed in some particular cases.
     */
    skipLibrariesDiscovery: boolean;
    /**
     * If set to true the returned build properties will be left unexpanded, with
     * the variables placeholders exactly as defined in the platform.
     */
    doNotExpandBuildProperties: boolean;
}
export interface CompileRequest_SourceOverrideEntry {
    key: string;
    value: string;
}
export interface CompileResponse {
    /** The output of the compilation process (stream) */
    outStream: Uint8Array;
    /** The error output of the compilation process (stream) */
    errStream: Uint8Array;
    /** The compiler build path */
    buildPath: string;
    /** The libraries used in the build */
    usedLibraries: Library[];
    /** The size of the executable split by sections */
    executableSectionsSize: ExecutableSectionSize[];
    /** The platform where the board is defined */
    boardPlatform: InstalledPlatformReference | undefined;
    /** The platform used for the build (if referenced from the board platform) */
    buildPlatform: InstalledPlatformReference | undefined;
    /** Completions reports of the compilation process (stream) */
    progress: TaskProgress | undefined;
    /** Build properties used for compiling */
    buildProperties: string[];
}
export interface ExecutableSectionSize {
    name: string;
    size: number;
    maxSize: number;
}
export declare const CompileRequest: {
    encode(message: CompileRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CompileRequest;
    fromJSON(object: any): CompileRequest;
    toJSON(message: CompileRequest): unknown;
    create(base?: DeepPartial<CompileRequest>): CompileRequest;
    fromPartial(object: DeepPartial<CompileRequest>): CompileRequest;
};
export declare const CompileRequest_SourceOverrideEntry: {
    encode(message: CompileRequest_SourceOverrideEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CompileRequest_SourceOverrideEntry;
    fromJSON(object: any): CompileRequest_SourceOverrideEntry;
    toJSON(message: CompileRequest_SourceOverrideEntry): unknown;
    create(base?: DeepPartial<CompileRequest_SourceOverrideEntry>): CompileRequest_SourceOverrideEntry;
    fromPartial(object: DeepPartial<CompileRequest_SourceOverrideEntry>): CompileRequest_SourceOverrideEntry;
};
export declare const CompileResponse: {
    encode(message: CompileResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CompileResponse;
    fromJSON(object: any): CompileResponse;
    toJSON(message: CompileResponse): unknown;
    create(base?: DeepPartial<CompileResponse>): CompileResponse;
    fromPartial(object: DeepPartial<CompileResponse>): CompileResponse;
};
export declare const ExecutableSectionSize: {
    encode(message: ExecutableSectionSize, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ExecutableSectionSize;
    fromJSON(object: any): ExecutableSectionSize;
    toJSON(message: ExecutableSectionSize): unknown;
    create(base?: DeepPartial<ExecutableSectionSize>): ExecutableSectionSize;
    fromPartial(object: DeepPartial<ExecutableSectionSize>): ExecutableSectionSize;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, '$case'>]?: DeepPartial<T[K]>;
} & {
    $case: T['$case'];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=compile.d.ts.map