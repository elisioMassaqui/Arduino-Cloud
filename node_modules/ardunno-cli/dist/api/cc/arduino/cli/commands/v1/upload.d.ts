import _m0 from 'protobufjs/minimal';
import { Instance, Programmer } from './common';
import { Port } from './port';
export interface UploadRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /**
     * Fully qualified board name of the target board (e.g., `arduino:avr:uno`).
     * If this field is not defined, the FQBN of the board attached to the sketch
     * via the `BoardAttach` method is used.
     */
    fqbn: string;
    /**
     * Path where the sketch to be uploaded is stored. Unless the `import_file`
     * field is defined, the compiled binary is assumed to be at the location and
     * filename under this path where it is saved by the `Compile` method.
     */
    sketchPath: string;
    /** The port of the board. */
    port: Port | undefined;
    /** Whether to turn on verbose output during the upload. */
    verbose: boolean;
    /**
     * After upload, verify that the contents of the memory on the board match the
     * uploaded binary.
     */
    verify: boolean;
    /**
     * When `import_file` is specified, it overrides the `import_dir` and
     * `sketch_path` params.
     */
    importFile: string;
    /**
     * Custom path to a directory containing compiled files. When `import_dir` is
     * not specified, the standard build directory under `sketch_path` is used.
     */
    importDir: string;
    /**
     * The programmer to use for upload. If set an UploadUsingProgrammer is
     * triggered instead of a normal upload. The UploadUsingProgrammer call may
     * also be used for explicit error check.
     */
    programmer: string;
    /**
     * If set to true, the actual upload will not be performed but a trace output
     * will be printed stdout. This is for debugging purposes.
     */
    dryRun: boolean;
    /**
     * User provided fields usually used by upload tools that need authentication
     * or in any case fields that can be customized by the user at upload time
     * and cannot be known previously.
     * For more info:
     * https://arduino.github.io/arduino-cli/latest/platform-specification/#user-provided-fields
     */
    userFields: {
        [key: string]: string;
    };
}
export interface UploadRequest_UserFieldsEntry {
    key: string;
    value: string;
}
export interface UploadResponse {
    message?: {
        $case: 'outStream';
        outStream: Uint8Array;
    } | {
        $case: 'errStream';
        errStream: Uint8Array;
    } | {
        $case: 'result';
        result: UploadResult;
    } | undefined;
}
export interface UploadResult {
    /**
     * When a board requires a port disconnection to perform the upload, this
     * field returns the port where the board reconnects after the upload.
     */
    updatedUploadPort: Port | undefined;
}
export interface ProgrammerIsRequiredForUploadError {
}
export interface UploadUsingProgrammerRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /**
     * Fully qualified board name of the target board (e.g., `arduino:avr:uno`).
     * If this field is not defined, the FQBN of the board attached to the sketch
     * via the `BoardAttach` method is used.
     */
    fqbn: string;
    /**
     * Path where the sketch to be uploaded is stored. Unless the `import_file`
     * field is defined, the compiled binary is assumed to be at the location and
     * filename under this path where it is saved by the `Compile` method.
     */
    sketchPath: string;
    /** The port of the board. */
    port: Port | undefined;
    /** Whether to turn on verbose output during the upload. */
    verbose: boolean;
    /**
     * After upload, verify that the contents of the memory on the board match the
     * uploaded binary.
     */
    verify: boolean;
    /**
     * When `import_file` is specified, it overrides the `import_dir` and
     * `sketch_path` params.
     */
    importFile: string;
    /**
     * Custom path to a directory containing compiled files. When `import_dir` is
     * not specified, the standard build directory under `sketch_path` is used.
     */
    importDir: string;
    /** The programmer to use for upload. */
    programmer: string;
    /**
     * If set to true, the actual upload will not be performed but a trace output
     * will be printed stdout. This is for debugging purposes.
     */
    dryRun: boolean;
    /**
     * User provided fields usually used by upload tools that need authentication
     * or in any case fields that can be customized by the user at upload time
     * and cannot be known previously.
     * For more info:
     * https://arduino.github.io/arduino-cli/latest/platform-specification/#user-provided-fields
     */
    userFields: {
        [key: string]: string;
    };
}
export interface UploadUsingProgrammerRequest_UserFieldsEntry {
    key: string;
    value: string;
}
export interface UploadUsingProgrammerResponse {
    /** The output of the upload process. */
    outStream: Uint8Array;
    /** The error output of the upload process. */
    errStream: Uint8Array;
}
export interface BurnBootloaderRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /** Fully qualified board name of the target board (e.g., `arduino:avr:uno`). */
    fqbn: string;
    /** The port of the programmer used to program the bootloader. */
    port: Port | undefined;
    /** Whether to turn on verbose output during the programming. */
    verbose: boolean;
    /**
     * After programming, verify the contents of the memory on the board match the
     * uploaded binary.
     */
    verify: boolean;
    /** The programmer to use for burning bootloader. */
    programmer: string;
    /**
     * If set to true, the actual upload will not be performed but a trace output
     * will be printed stdout. This is for debugging purposes.
     */
    dryRun: boolean;
    /**
     * User provided fields usually used by upload tools that need authentication
     * or in any case fields that can be customized by the user at upload time
     * and cannot be known previously.
     * For more info:
     * https://arduino.github.io/arduino-cli/latest/platform-specification/#user-provided-fields
     */
    userFields: {
        [key: string]: string;
    };
}
export interface BurnBootloaderRequest_UserFieldsEntry {
    key: string;
    value: string;
}
export interface BurnBootloaderResponse {
    /** The output of the burn bootloader process. */
    outStream: Uint8Array;
    /** The error output of the burn bootloader process. */
    errStream: Uint8Array;
}
export interface ListProgrammersAvailableForUploadRequest {
    instance: Instance | undefined;
    fqbn: string;
}
export interface ListProgrammersAvailableForUploadResponse {
    programmers: Programmer[];
}
export interface SupportedUserFieldsRequest {
    instance: Instance | undefined;
    fqbn: string;
    /**
     * Protocol that will be used to upload, this information is
     * necessary to pick the right upload tool for the board specified
     * with the FQBN.
     */
    protocol: string;
}
export interface UserField {
    /** Id of the tool that supports this field */
    toolId: string;
    /** Name used internally to store and retrieve this field */
    name: string;
    /** Label is the text shown to the user when they need to input this field */
    label: string;
    /**
     * True if the value of the field must not be shown when typing, for example
     * when the user inputs a network password
     */
    secret: boolean;
}
export interface SupportedUserFieldsResponse {
    /**
     * User fields supported by board specified in SupportedUserFieldsRequest.
     * If board doesn't support any field it will be empty.
     */
    userFields: UserField[];
}
export declare const UploadRequest: {
    encode(message: UploadRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UploadRequest;
    fromJSON(object: any): UploadRequest;
    toJSON(message: UploadRequest): unknown;
    create(base?: DeepPartial<UploadRequest>): UploadRequest;
    fromPartial(object: DeepPartial<UploadRequest>): UploadRequest;
};
export declare const UploadRequest_UserFieldsEntry: {
    encode(message: UploadRequest_UserFieldsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UploadRequest_UserFieldsEntry;
    fromJSON(object: any): UploadRequest_UserFieldsEntry;
    toJSON(message: UploadRequest_UserFieldsEntry): unknown;
    create(base?: DeepPartial<UploadRequest_UserFieldsEntry>): UploadRequest_UserFieldsEntry;
    fromPartial(object: DeepPartial<UploadRequest_UserFieldsEntry>): UploadRequest_UserFieldsEntry;
};
export declare const UploadResponse: {
    encode(message: UploadResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UploadResponse;
    fromJSON(object: any): UploadResponse;
    toJSON(message: UploadResponse): unknown;
    create(base?: DeepPartial<UploadResponse>): UploadResponse;
    fromPartial(object: DeepPartial<UploadResponse>): UploadResponse;
};
export declare const UploadResult: {
    encode(message: UploadResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UploadResult;
    fromJSON(object: any): UploadResult;
    toJSON(message: UploadResult): unknown;
    create(base?: DeepPartial<UploadResult>): UploadResult;
    fromPartial(object: DeepPartial<UploadResult>): UploadResult;
};
export declare const ProgrammerIsRequiredForUploadError: {
    encode(_: ProgrammerIsRequiredForUploadError, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ProgrammerIsRequiredForUploadError;
    fromJSON(_: any): ProgrammerIsRequiredForUploadError;
    toJSON(_: ProgrammerIsRequiredForUploadError): unknown;
    create(base?: DeepPartial<ProgrammerIsRequiredForUploadError>): ProgrammerIsRequiredForUploadError;
    fromPartial(_: DeepPartial<ProgrammerIsRequiredForUploadError>): ProgrammerIsRequiredForUploadError;
};
export declare const UploadUsingProgrammerRequest: {
    encode(message: UploadUsingProgrammerRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UploadUsingProgrammerRequest;
    fromJSON(object: any): UploadUsingProgrammerRequest;
    toJSON(message: UploadUsingProgrammerRequest): unknown;
    create(base?: DeepPartial<UploadUsingProgrammerRequest>): UploadUsingProgrammerRequest;
    fromPartial(object: DeepPartial<UploadUsingProgrammerRequest>): UploadUsingProgrammerRequest;
};
export declare const UploadUsingProgrammerRequest_UserFieldsEntry: {
    encode(message: UploadUsingProgrammerRequest_UserFieldsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UploadUsingProgrammerRequest_UserFieldsEntry;
    fromJSON(object: any): UploadUsingProgrammerRequest_UserFieldsEntry;
    toJSON(message: UploadUsingProgrammerRequest_UserFieldsEntry): unknown;
    create(base?: DeepPartial<UploadUsingProgrammerRequest_UserFieldsEntry>): UploadUsingProgrammerRequest_UserFieldsEntry;
    fromPartial(object: DeepPartial<UploadUsingProgrammerRequest_UserFieldsEntry>): UploadUsingProgrammerRequest_UserFieldsEntry;
};
export declare const UploadUsingProgrammerResponse: {
    encode(message: UploadUsingProgrammerResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UploadUsingProgrammerResponse;
    fromJSON(object: any): UploadUsingProgrammerResponse;
    toJSON(message: UploadUsingProgrammerResponse): unknown;
    create(base?: DeepPartial<UploadUsingProgrammerResponse>): UploadUsingProgrammerResponse;
    fromPartial(object: DeepPartial<UploadUsingProgrammerResponse>): UploadUsingProgrammerResponse;
};
export declare const BurnBootloaderRequest: {
    encode(message: BurnBootloaderRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BurnBootloaderRequest;
    fromJSON(object: any): BurnBootloaderRequest;
    toJSON(message: BurnBootloaderRequest): unknown;
    create(base?: DeepPartial<BurnBootloaderRequest>): BurnBootloaderRequest;
    fromPartial(object: DeepPartial<BurnBootloaderRequest>): BurnBootloaderRequest;
};
export declare const BurnBootloaderRequest_UserFieldsEntry: {
    encode(message: BurnBootloaderRequest_UserFieldsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BurnBootloaderRequest_UserFieldsEntry;
    fromJSON(object: any): BurnBootloaderRequest_UserFieldsEntry;
    toJSON(message: BurnBootloaderRequest_UserFieldsEntry): unknown;
    create(base?: DeepPartial<BurnBootloaderRequest_UserFieldsEntry>): BurnBootloaderRequest_UserFieldsEntry;
    fromPartial(object: DeepPartial<BurnBootloaderRequest_UserFieldsEntry>): BurnBootloaderRequest_UserFieldsEntry;
};
export declare const BurnBootloaderResponse: {
    encode(message: BurnBootloaderResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BurnBootloaderResponse;
    fromJSON(object: any): BurnBootloaderResponse;
    toJSON(message: BurnBootloaderResponse): unknown;
    create(base?: DeepPartial<BurnBootloaderResponse>): BurnBootloaderResponse;
    fromPartial(object: DeepPartial<BurnBootloaderResponse>): BurnBootloaderResponse;
};
export declare const ListProgrammersAvailableForUploadRequest: {
    encode(message: ListProgrammersAvailableForUploadRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ListProgrammersAvailableForUploadRequest;
    fromJSON(object: any): ListProgrammersAvailableForUploadRequest;
    toJSON(message: ListProgrammersAvailableForUploadRequest): unknown;
    create(base?: DeepPartial<ListProgrammersAvailableForUploadRequest>): ListProgrammersAvailableForUploadRequest;
    fromPartial(object: DeepPartial<ListProgrammersAvailableForUploadRequest>): ListProgrammersAvailableForUploadRequest;
};
export declare const ListProgrammersAvailableForUploadResponse: {
    encode(message: ListProgrammersAvailableForUploadResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ListProgrammersAvailableForUploadResponse;
    fromJSON(object: any): ListProgrammersAvailableForUploadResponse;
    toJSON(message: ListProgrammersAvailableForUploadResponse): unknown;
    create(base?: DeepPartial<ListProgrammersAvailableForUploadResponse>): ListProgrammersAvailableForUploadResponse;
    fromPartial(object: DeepPartial<ListProgrammersAvailableForUploadResponse>): ListProgrammersAvailableForUploadResponse;
};
export declare const SupportedUserFieldsRequest: {
    encode(message: SupportedUserFieldsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SupportedUserFieldsRequest;
    fromJSON(object: any): SupportedUserFieldsRequest;
    toJSON(message: SupportedUserFieldsRequest): unknown;
    create(base?: DeepPartial<SupportedUserFieldsRequest>): SupportedUserFieldsRequest;
    fromPartial(object: DeepPartial<SupportedUserFieldsRequest>): SupportedUserFieldsRequest;
};
export declare const UserField: {
    encode(message: UserField, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserField;
    fromJSON(object: any): UserField;
    toJSON(message: UserField): unknown;
    create(base?: DeepPartial<UserField>): UserField;
    fromPartial(object: DeepPartial<UserField>): UserField;
};
export declare const SupportedUserFieldsResponse: {
    encode(message: SupportedUserFieldsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SupportedUserFieldsResponse;
    fromJSON(object: any): SupportedUserFieldsResponse;
    toJSON(message: SupportedUserFieldsResponse): unknown;
    create(base?: DeepPartial<SupportedUserFieldsResponse>): SupportedUserFieldsResponse;
    fromPartial(object: DeepPartial<SupportedUserFieldsResponse>): SupportedUserFieldsResponse;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, '$case'>]?: DeepPartial<T[K]>;
} & {
    $case: T['$case'];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=upload.d.ts.map