"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitLibraryInstallResponse = exports.GitLibraryInstallRequest = exports.ZipLibraryInstallResponse = exports.ZipLibraryInstallRequest = exports.Library_CompatibleWithEntry = exports.Library_PropertiesEntry = exports.Library = exports.InstalledLibrary = exports.LibraryListResponse = exports.LibraryListRequest = exports.DownloadResource = exports.LibraryDependency = exports.LibraryRelease = exports.SearchedLibrary_ReleasesEntry = exports.SearchedLibrary = exports.LibrarySearchResponse = exports.LibrarySearchRequest = exports.LibraryDependencyStatus = exports.LibraryResolveDependenciesResponse = exports.LibraryResolveDependenciesRequest = exports.LibraryUpgradeAllResponse = exports.LibraryUpgradeAllRequest = exports.LibraryUninstallResponse = exports.LibraryUninstallRequest = exports.LibraryUpgradeResponse = exports.LibraryUpgradeRequest = exports.LibraryInstallResponse = exports.LibraryInstallRequest = exports.LibraryDownloadResponse = exports.LibraryDownloadRequest = exports.libraryLocationToJSON = exports.libraryLocationFromJSON = exports.LibraryLocation = exports.libraryLayoutToJSON = exports.libraryLayoutFromJSON = exports.LibraryLayout = exports.librarySearchStatusToJSON = exports.librarySearchStatusFromJSON = exports.LibrarySearchStatus = exports.libraryInstallLocationToJSON = exports.libraryInstallLocationFromJSON = exports.LibraryInstallLocation = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const common_1 = require("./common");
var LibraryInstallLocation;
(function (LibraryInstallLocation) {
    /**
     * LIBRARY_INSTALL_LOCATION_USER - In the `libraries` subdirectory of the user directory (sketchbook). This is
     * the default if not specified.
     */
    LibraryInstallLocation[LibraryInstallLocation["LIBRARY_INSTALL_LOCATION_USER"] = 0] = "LIBRARY_INSTALL_LOCATION_USER";
    /** LIBRARY_INSTALL_LOCATION_BUILTIN - In the configured 'builtin.libraries' directory. */
    LibraryInstallLocation[LibraryInstallLocation["LIBRARY_INSTALL_LOCATION_BUILTIN"] = 1] = "LIBRARY_INSTALL_LOCATION_BUILTIN";
    LibraryInstallLocation[LibraryInstallLocation["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LibraryInstallLocation = exports.LibraryInstallLocation || (exports.LibraryInstallLocation = {}));
function libraryInstallLocationFromJSON(object) {
    switch (object) {
        case 0:
        case 'LIBRARY_INSTALL_LOCATION_USER':
            return LibraryInstallLocation.LIBRARY_INSTALL_LOCATION_USER;
        case 1:
        case 'LIBRARY_INSTALL_LOCATION_BUILTIN':
            return LibraryInstallLocation.LIBRARY_INSTALL_LOCATION_BUILTIN;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return LibraryInstallLocation.UNRECOGNIZED;
    }
}
exports.libraryInstallLocationFromJSON = libraryInstallLocationFromJSON;
function libraryInstallLocationToJSON(object) {
    switch (object) {
        case LibraryInstallLocation.LIBRARY_INSTALL_LOCATION_USER:
            return 'LIBRARY_INSTALL_LOCATION_USER';
        case LibraryInstallLocation.LIBRARY_INSTALL_LOCATION_BUILTIN:
            return 'LIBRARY_INSTALL_LOCATION_BUILTIN';
        case LibraryInstallLocation.UNRECOGNIZED:
        default:
            return 'UNRECOGNIZED';
    }
}
exports.libraryInstallLocationToJSON = libraryInstallLocationToJSON;
var LibrarySearchStatus;
(function (LibrarySearchStatus) {
    /** LIBRARY_SEARCH_STATUS_FAILED - No search results were found. */
    LibrarySearchStatus[LibrarySearchStatus["LIBRARY_SEARCH_STATUS_FAILED"] = 0] = "LIBRARY_SEARCH_STATUS_FAILED";
    /** LIBRARY_SEARCH_STATUS_SUCCESS - Search results were found. */
    LibrarySearchStatus[LibrarySearchStatus["LIBRARY_SEARCH_STATUS_SUCCESS"] = 1] = "LIBRARY_SEARCH_STATUS_SUCCESS";
    LibrarySearchStatus[LibrarySearchStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LibrarySearchStatus = exports.LibrarySearchStatus || (exports.LibrarySearchStatus = {}));
function librarySearchStatusFromJSON(object) {
    switch (object) {
        case 0:
        case 'LIBRARY_SEARCH_STATUS_FAILED':
            return LibrarySearchStatus.LIBRARY_SEARCH_STATUS_FAILED;
        case 1:
        case 'LIBRARY_SEARCH_STATUS_SUCCESS':
            return LibrarySearchStatus.LIBRARY_SEARCH_STATUS_SUCCESS;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return LibrarySearchStatus.UNRECOGNIZED;
    }
}
exports.librarySearchStatusFromJSON = librarySearchStatusFromJSON;
function librarySearchStatusToJSON(object) {
    switch (object) {
        case LibrarySearchStatus.LIBRARY_SEARCH_STATUS_FAILED:
            return 'LIBRARY_SEARCH_STATUS_FAILED';
        case LibrarySearchStatus.LIBRARY_SEARCH_STATUS_SUCCESS:
            return 'LIBRARY_SEARCH_STATUS_SUCCESS';
        case LibrarySearchStatus.UNRECOGNIZED:
        default:
            return 'UNRECOGNIZED';
    }
}
exports.librarySearchStatusToJSON = librarySearchStatusToJSON;
var LibraryLayout;
(function (LibraryLayout) {
    /** LIBRARY_LAYOUT_FLAT - Library is in the 1.0 Arduino library format. */
    LibraryLayout[LibraryLayout["LIBRARY_LAYOUT_FLAT"] = 0] = "LIBRARY_LAYOUT_FLAT";
    /** LIBRARY_LAYOUT_RECURSIVE - Library is in the 1.5 Arduino library format. */
    LibraryLayout[LibraryLayout["LIBRARY_LAYOUT_RECURSIVE"] = 1] = "LIBRARY_LAYOUT_RECURSIVE";
    LibraryLayout[LibraryLayout["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LibraryLayout = exports.LibraryLayout || (exports.LibraryLayout = {}));
function libraryLayoutFromJSON(object) {
    switch (object) {
        case 0:
        case 'LIBRARY_LAYOUT_FLAT':
            return LibraryLayout.LIBRARY_LAYOUT_FLAT;
        case 1:
        case 'LIBRARY_LAYOUT_RECURSIVE':
            return LibraryLayout.LIBRARY_LAYOUT_RECURSIVE;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return LibraryLayout.UNRECOGNIZED;
    }
}
exports.libraryLayoutFromJSON = libraryLayoutFromJSON;
function libraryLayoutToJSON(object) {
    switch (object) {
        case LibraryLayout.LIBRARY_LAYOUT_FLAT:
            return 'LIBRARY_LAYOUT_FLAT';
        case LibraryLayout.LIBRARY_LAYOUT_RECURSIVE:
            return 'LIBRARY_LAYOUT_RECURSIVE';
        case LibraryLayout.UNRECOGNIZED:
        default:
            return 'UNRECOGNIZED';
    }
}
exports.libraryLayoutToJSON = libraryLayoutToJSON;
var LibraryLocation;
(function (LibraryLocation) {
    /** LIBRARY_LOCATION_BUILTIN - In the configured 'builtin.libraries' directory. */
    LibraryLocation[LibraryLocation["LIBRARY_LOCATION_BUILTIN"] = 0] = "LIBRARY_LOCATION_BUILTIN";
    /** LIBRARY_LOCATION_USER - In the `libraries` subdirectory of the user directory (sketchbook). */
    LibraryLocation[LibraryLocation["LIBRARY_LOCATION_USER"] = 1] = "LIBRARY_LOCATION_USER";
    /** LIBRARY_LOCATION_PLATFORM_BUILTIN - In the `libraries` subdirectory of a platform. */
    LibraryLocation[LibraryLocation["LIBRARY_LOCATION_PLATFORM_BUILTIN"] = 2] = "LIBRARY_LOCATION_PLATFORM_BUILTIN";
    /**
     * LIBRARY_LOCATION_REFERENCED_PLATFORM_BUILTIN - When `LibraryLocation` is used in a context where a board is specified,
     * this indicates the library is in the `libraries` subdirectory of a
     * platform referenced by the board's platform.
     */
    LibraryLocation[LibraryLocation["LIBRARY_LOCATION_REFERENCED_PLATFORM_BUILTIN"] = 3] = "LIBRARY_LOCATION_REFERENCED_PLATFORM_BUILTIN";
    /** LIBRARY_LOCATION_UNMANAGED - Outside the `libraries` folders managed by the CLI. */
    LibraryLocation[LibraryLocation["LIBRARY_LOCATION_UNMANAGED"] = 4] = "LIBRARY_LOCATION_UNMANAGED";
    LibraryLocation[LibraryLocation["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LibraryLocation = exports.LibraryLocation || (exports.LibraryLocation = {}));
function libraryLocationFromJSON(object) {
    switch (object) {
        case 0:
        case 'LIBRARY_LOCATION_BUILTIN':
            return LibraryLocation.LIBRARY_LOCATION_BUILTIN;
        case 1:
        case 'LIBRARY_LOCATION_USER':
            return LibraryLocation.LIBRARY_LOCATION_USER;
        case 2:
        case 'LIBRARY_LOCATION_PLATFORM_BUILTIN':
            return LibraryLocation.LIBRARY_LOCATION_PLATFORM_BUILTIN;
        case 3:
        case 'LIBRARY_LOCATION_REFERENCED_PLATFORM_BUILTIN':
            return LibraryLocation.LIBRARY_LOCATION_REFERENCED_PLATFORM_BUILTIN;
        case 4:
        case 'LIBRARY_LOCATION_UNMANAGED':
            return LibraryLocation.LIBRARY_LOCATION_UNMANAGED;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return LibraryLocation.UNRECOGNIZED;
    }
}
exports.libraryLocationFromJSON = libraryLocationFromJSON;
function libraryLocationToJSON(object) {
    switch (object) {
        case LibraryLocation.LIBRARY_LOCATION_BUILTIN:
            return 'LIBRARY_LOCATION_BUILTIN';
        case LibraryLocation.LIBRARY_LOCATION_USER:
            return 'LIBRARY_LOCATION_USER';
        case LibraryLocation.LIBRARY_LOCATION_PLATFORM_BUILTIN:
            return 'LIBRARY_LOCATION_PLATFORM_BUILTIN';
        case LibraryLocation.LIBRARY_LOCATION_REFERENCED_PLATFORM_BUILTIN:
            return 'LIBRARY_LOCATION_REFERENCED_PLATFORM_BUILTIN';
        case LibraryLocation.LIBRARY_LOCATION_UNMANAGED:
            return 'LIBRARY_LOCATION_UNMANAGED';
        case LibraryLocation.UNRECOGNIZED:
        default:
            return 'UNRECOGNIZED';
    }
}
exports.libraryLocationToJSON = libraryLocationToJSON;
function createBaseLibraryDownloadRequest() {
    return { instance: undefined, name: '', version: '' };
}
exports.LibraryDownloadRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== '') {
            writer.uint32(18).string(message.name);
        }
        if (message.version !== '') {
            writer.uint32(26).string(message.version);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryDownloadRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            name: isSet(object.name) ? String(object.name) : '',
            version: isSet(object.version) ? String(object.version) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.name !== undefined && (obj.name = message.name);
        message.version !== undefined && (obj.version = message.version);
        return obj;
    },
    create(base) {
        return exports.LibraryDownloadRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLibraryDownloadRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : '';
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseLibraryDownloadResponse() {
    return { progress: undefined };
}
exports.LibraryDownloadResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.progress !== undefined) {
            common_1.DownloadProgress.encode(message.progress, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryDownloadResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.progress = common_1.DownloadProgress.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            progress: isSet(object.progress)
                ? common_1.DownloadProgress.fromJSON(object.progress)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.progress !== undefined &&
            (obj.progress = message.progress
                ? common_1.DownloadProgress.toJSON(message.progress)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.LibraryDownloadResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseLibraryDownloadResponse();
        message.progress =
            object.progress !== undefined && object.progress !== null
                ? common_1.DownloadProgress.fromPartial(object.progress)
                : undefined;
        return message;
    },
};
function createBaseLibraryInstallRequest() {
    return {
        instance: undefined,
        name: '',
        version: '',
        noDeps: false,
        noOverwrite: false,
        installLocation: 0,
    };
}
exports.LibraryInstallRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== '') {
            writer.uint32(18).string(message.name);
        }
        if (message.version !== '') {
            writer.uint32(26).string(message.version);
        }
        if (message.noDeps === true) {
            writer.uint32(32).bool(message.noDeps);
        }
        if (message.noOverwrite === true) {
            writer.uint32(40).bool(message.noOverwrite);
        }
        if (message.installLocation !== 0) {
            writer.uint32(48).int32(message.installLocation);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryInstallRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.noDeps = reader.bool();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.noOverwrite = reader.bool();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.installLocation = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            name: isSet(object.name) ? String(object.name) : '',
            version: isSet(object.version) ? String(object.version) : '',
            noDeps: isSet(object.noDeps) ? Boolean(object.noDeps) : false,
            noOverwrite: isSet(object.noOverwrite)
                ? Boolean(object.noOverwrite)
                : false,
            installLocation: isSet(object.installLocation)
                ? libraryInstallLocationFromJSON(object.installLocation)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.name !== undefined && (obj.name = message.name);
        message.version !== undefined && (obj.version = message.version);
        message.noDeps !== undefined && (obj.noDeps = message.noDeps);
        message.noOverwrite !== undefined &&
            (obj.noOverwrite = message.noOverwrite);
        message.installLocation !== undefined &&
            (obj.installLocation = libraryInstallLocationToJSON(message.installLocation));
        return obj;
    },
    create(base) {
        return exports.LibraryInstallRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseLibraryInstallRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : '';
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : '';
        message.noDeps = (_c = object.noDeps) !== null && _c !== void 0 ? _c : false;
        message.noOverwrite = (_d = object.noOverwrite) !== null && _d !== void 0 ? _d : false;
        message.installLocation = (_e = object.installLocation) !== null && _e !== void 0 ? _e : 0;
        return message;
    },
};
function createBaseLibraryInstallResponse() {
    return { progress: undefined, taskProgress: undefined };
}
exports.LibraryInstallResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.progress !== undefined) {
            common_1.DownloadProgress.encode(message.progress, writer.uint32(10).fork()).ldelim();
        }
        if (message.taskProgress !== undefined) {
            common_1.TaskProgress.encode(message.taskProgress, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryInstallResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.progress = common_1.DownloadProgress.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.taskProgress = common_1.TaskProgress.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            progress: isSet(object.progress)
                ? common_1.DownloadProgress.fromJSON(object.progress)
                : undefined,
            taskProgress: isSet(object.taskProgress)
                ? common_1.TaskProgress.fromJSON(object.taskProgress)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.progress !== undefined &&
            (obj.progress = message.progress
                ? common_1.DownloadProgress.toJSON(message.progress)
                : undefined);
        message.taskProgress !== undefined &&
            (obj.taskProgress = message.taskProgress
                ? common_1.TaskProgress.toJSON(message.taskProgress)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.LibraryInstallResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseLibraryInstallResponse();
        message.progress =
            object.progress !== undefined && object.progress !== null
                ? common_1.DownloadProgress.fromPartial(object.progress)
                : undefined;
        message.taskProgress =
            object.taskProgress !== undefined && object.taskProgress !== null
                ? common_1.TaskProgress.fromPartial(object.taskProgress)
                : undefined;
        return message;
    },
};
function createBaseLibraryUpgradeRequest() {
    return { instance: undefined, name: '', noDeps: false };
}
exports.LibraryUpgradeRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== '') {
            writer.uint32(18).string(message.name);
        }
        if (message.noDeps === true) {
            writer.uint32(24).bool(message.noDeps);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryUpgradeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.noDeps = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            name: isSet(object.name) ? String(object.name) : '',
            noDeps: isSet(object.noDeps) ? Boolean(object.noDeps) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.name !== undefined && (obj.name = message.name);
        message.noDeps !== undefined && (obj.noDeps = message.noDeps);
        return obj;
    },
    create(base) {
        return exports.LibraryUpgradeRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLibraryUpgradeRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : '';
        message.noDeps = (_b = object.noDeps) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseLibraryUpgradeResponse() {
    return { progress: undefined, taskProgress: undefined };
}
exports.LibraryUpgradeResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.progress !== undefined) {
            common_1.DownloadProgress.encode(message.progress, writer.uint32(10).fork()).ldelim();
        }
        if (message.taskProgress !== undefined) {
            common_1.TaskProgress.encode(message.taskProgress, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryUpgradeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.progress = common_1.DownloadProgress.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.taskProgress = common_1.TaskProgress.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            progress: isSet(object.progress)
                ? common_1.DownloadProgress.fromJSON(object.progress)
                : undefined,
            taskProgress: isSet(object.taskProgress)
                ? common_1.TaskProgress.fromJSON(object.taskProgress)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.progress !== undefined &&
            (obj.progress = message.progress
                ? common_1.DownloadProgress.toJSON(message.progress)
                : undefined);
        message.taskProgress !== undefined &&
            (obj.taskProgress = message.taskProgress
                ? common_1.TaskProgress.toJSON(message.taskProgress)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.LibraryUpgradeResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseLibraryUpgradeResponse();
        message.progress =
            object.progress !== undefined && object.progress !== null
                ? common_1.DownloadProgress.fromPartial(object.progress)
                : undefined;
        message.taskProgress =
            object.taskProgress !== undefined && object.taskProgress !== null
                ? common_1.TaskProgress.fromPartial(object.taskProgress)
                : undefined;
        return message;
    },
};
function createBaseLibraryUninstallRequest() {
    return { instance: undefined, name: '', version: '' };
}
exports.LibraryUninstallRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== '') {
            writer.uint32(18).string(message.name);
        }
        if (message.version !== '') {
            writer.uint32(26).string(message.version);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryUninstallRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            name: isSet(object.name) ? String(object.name) : '',
            version: isSet(object.version) ? String(object.version) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.name !== undefined && (obj.name = message.name);
        message.version !== undefined && (obj.version = message.version);
        return obj;
    },
    create(base) {
        return exports.LibraryUninstallRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLibraryUninstallRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : '';
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseLibraryUninstallResponse() {
    return { taskProgress: undefined };
}
exports.LibraryUninstallResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.taskProgress !== undefined) {
            common_1.TaskProgress.encode(message.taskProgress, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryUninstallResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.taskProgress = common_1.TaskProgress.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            taskProgress: isSet(object.taskProgress)
                ? common_1.TaskProgress.fromJSON(object.taskProgress)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.taskProgress !== undefined &&
            (obj.taskProgress = message.taskProgress
                ? common_1.TaskProgress.toJSON(message.taskProgress)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.LibraryUninstallResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseLibraryUninstallResponse();
        message.taskProgress =
            object.taskProgress !== undefined && object.taskProgress !== null
                ? common_1.TaskProgress.fromPartial(object.taskProgress)
                : undefined;
        return message;
    },
};
function createBaseLibraryUpgradeAllRequest() {
    return { instance: undefined };
}
exports.LibraryUpgradeAllRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryUpgradeAllRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.LibraryUpgradeAllRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseLibraryUpgradeAllRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        return message;
    },
};
function createBaseLibraryUpgradeAllResponse() {
    return { progress: undefined, taskProgress: undefined };
}
exports.LibraryUpgradeAllResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.progress !== undefined) {
            common_1.DownloadProgress.encode(message.progress, writer.uint32(10).fork()).ldelim();
        }
        if (message.taskProgress !== undefined) {
            common_1.TaskProgress.encode(message.taskProgress, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryUpgradeAllResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.progress = common_1.DownloadProgress.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.taskProgress = common_1.TaskProgress.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            progress: isSet(object.progress)
                ? common_1.DownloadProgress.fromJSON(object.progress)
                : undefined,
            taskProgress: isSet(object.taskProgress)
                ? common_1.TaskProgress.fromJSON(object.taskProgress)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.progress !== undefined &&
            (obj.progress = message.progress
                ? common_1.DownloadProgress.toJSON(message.progress)
                : undefined);
        message.taskProgress !== undefined &&
            (obj.taskProgress = message.taskProgress
                ? common_1.TaskProgress.toJSON(message.taskProgress)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.LibraryUpgradeAllResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseLibraryUpgradeAllResponse();
        message.progress =
            object.progress !== undefined && object.progress !== null
                ? common_1.DownloadProgress.fromPartial(object.progress)
                : undefined;
        message.taskProgress =
            object.taskProgress !== undefined && object.taskProgress !== null
                ? common_1.TaskProgress.fromPartial(object.taskProgress)
                : undefined;
        return message;
    },
};
function createBaseLibraryResolveDependenciesRequest() {
    return { instance: undefined, name: '', version: '' };
}
exports.LibraryResolveDependenciesRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== '') {
            writer.uint32(18).string(message.name);
        }
        if (message.version !== '') {
            writer.uint32(26).string(message.version);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryResolveDependenciesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            name: isSet(object.name) ? String(object.name) : '',
            version: isSet(object.version) ? String(object.version) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.name !== undefined && (obj.name = message.name);
        message.version !== undefined && (obj.version = message.version);
        return obj;
    },
    create(base) {
        return exports.LibraryResolveDependenciesRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLibraryResolveDependenciesRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : '';
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseLibraryResolveDependenciesResponse() {
    return { dependencies: [] };
}
exports.LibraryResolveDependenciesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.dependencies) {
            exports.LibraryDependencyStatus.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryResolveDependenciesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.dependencies.push(exports.LibraryDependencyStatus.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            dependencies: Array.isArray(object === null || object === void 0 ? void 0 : object.dependencies)
                ? object.dependencies.map((e) => exports.LibraryDependencyStatus.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.dependencies) {
            obj.dependencies = message.dependencies.map((e) => e ? exports.LibraryDependencyStatus.toJSON(e) : undefined);
        }
        else {
            obj.dependencies = [];
        }
        return obj;
    },
    create(base) {
        return exports.LibraryResolveDependenciesResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseLibraryResolveDependenciesResponse();
        message.dependencies =
            ((_a = object.dependencies) === null || _a === void 0 ? void 0 : _a.map((e) => exports.LibraryDependencyStatus.fromPartial(e))) || [];
        return message;
    },
};
function createBaseLibraryDependencyStatus() {
    return { name: '', versionRequired: '', versionInstalled: '' };
}
exports.LibraryDependencyStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== '') {
            writer.uint32(10).string(message.name);
        }
        if (message.versionRequired !== '') {
            writer.uint32(18).string(message.versionRequired);
        }
        if (message.versionInstalled !== '') {
            writer.uint32(26).string(message.versionInstalled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryDependencyStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.versionRequired = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.versionInstalled = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : '',
            versionRequired: isSet(object.versionRequired)
                ? String(object.versionRequired)
                : '',
            versionInstalled: isSet(object.versionInstalled)
                ? String(object.versionInstalled)
                : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.versionRequired !== undefined &&
            (obj.versionRequired = message.versionRequired);
        message.versionInstalled !== undefined &&
            (obj.versionInstalled = message.versionInstalled);
        return obj;
    },
    create(base) {
        return exports.LibraryDependencyStatus.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseLibraryDependencyStatus();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : '';
        message.versionRequired = (_b = object.versionRequired) !== null && _b !== void 0 ? _b : '';
        message.versionInstalled = (_c = object.versionInstalled) !== null && _c !== void 0 ? _c : '';
        return message;
    },
};
function createBaseLibrarySearchRequest() {
    return {
        instance: undefined,
        query: '',
        omitReleasesDetails: false,
        searchArgs: '',
    };
}
exports.LibrarySearchRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.query !== '') {
            writer.uint32(18).string(message.query);
        }
        if (message.omitReleasesDetails === true) {
            writer.uint32(24).bool(message.omitReleasesDetails);
        }
        if (message.searchArgs !== '') {
            writer.uint32(34).string(message.searchArgs);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibrarySearchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.query = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.omitReleasesDetails = reader.bool();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.searchArgs = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            query: isSet(object.query) ? String(object.query) : '',
            omitReleasesDetails: isSet(object.omitReleasesDetails)
                ? Boolean(object.omitReleasesDetails)
                : false,
            searchArgs: isSet(object.searchArgs)
                ? String(object.searchArgs)
                : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.query !== undefined && (obj.query = message.query);
        message.omitReleasesDetails !== undefined &&
            (obj.omitReleasesDetails = message.omitReleasesDetails);
        message.searchArgs !== undefined &&
            (obj.searchArgs = message.searchArgs);
        return obj;
    },
    create(base) {
        return exports.LibrarySearchRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseLibrarySearchRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.query = (_a = object.query) !== null && _a !== void 0 ? _a : '';
        message.omitReleasesDetails = (_b = object.omitReleasesDetails) !== null && _b !== void 0 ? _b : false;
        message.searchArgs = (_c = object.searchArgs) !== null && _c !== void 0 ? _c : '';
        return message;
    },
};
function createBaseLibrarySearchResponse() {
    return { libraries: [], status: 0 };
}
exports.LibrarySearchResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.libraries) {
            exports.SearchedLibrary.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.status !== 0) {
            writer.uint32(16).int32(message.status);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibrarySearchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.libraries.push(exports.SearchedLibrary.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            libraries: Array.isArray(object === null || object === void 0 ? void 0 : object.libraries)
                ? object.libraries.map((e) => exports.SearchedLibrary.fromJSON(e))
                : [],
            status: isSet(object.status)
                ? librarySearchStatusFromJSON(object.status)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.libraries) {
            obj.libraries = message.libraries.map((e) => e ? exports.SearchedLibrary.toJSON(e) : undefined);
        }
        else {
            obj.libraries = [];
        }
        message.status !== undefined &&
            (obj.status = librarySearchStatusToJSON(message.status));
        return obj;
    },
    create(base) {
        return exports.LibrarySearchResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLibrarySearchResponse();
        message.libraries =
            ((_a = object.libraries) === null || _a === void 0 ? void 0 : _a.map((e) => exports.SearchedLibrary.fromPartial(e))) || [];
        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseSearchedLibrary() {
    return { name: '', releases: {}, latest: undefined, availableVersions: [] };
}
exports.SearchedLibrary = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== '') {
            writer.uint32(10).string(message.name);
        }
        Object.entries(message.releases).forEach(([key, value]) => {
            exports.SearchedLibrary_ReleasesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.latest !== undefined) {
            exports.LibraryRelease.encode(message.latest, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.availableVersions) {
            writer.uint32(34).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchedLibrary();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = exports.SearchedLibrary_ReleasesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.releases[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.latest = exports.LibraryRelease.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.availableVersions.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : '',
            releases: isObject(object.releases)
                ? Object.entries(object.releases).reduce((acc, [key, value]) => {
                    acc[key] = exports.LibraryRelease.fromJSON(value);
                    return acc;
                }, {})
                : {},
            latest: isSet(object.latest)
                ? exports.LibraryRelease.fromJSON(object.latest)
                : undefined,
            availableVersions: Array.isArray(object === null || object === void 0 ? void 0 : object.availableVersions)
                ? object.availableVersions.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        obj.releases = {};
        if (message.releases) {
            Object.entries(message.releases).forEach(([k, v]) => {
                obj.releases[k] = exports.LibraryRelease.toJSON(v);
            });
        }
        message.latest !== undefined &&
            (obj.latest = message.latest
                ? exports.LibraryRelease.toJSON(message.latest)
                : undefined);
        if (message.availableVersions) {
            obj.availableVersions = message.availableVersions.map((e) => e);
        }
        else {
            obj.availableVersions = [];
        }
        return obj;
    },
    create(base) {
        return exports.SearchedLibrary.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSearchedLibrary();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : '';
        message.releases = Object.entries((_b = object.releases) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.LibraryRelease.fromPartial(value);
            }
            return acc;
        }, {});
        message.latest =
            object.latest !== undefined && object.latest !== null
                ? exports.LibraryRelease.fromPartial(object.latest)
                : undefined;
        message.availableVersions =
            ((_c = object.availableVersions) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
    },
};
function createBaseSearchedLibrary_ReleasesEntry() {
    return { key: '', value: undefined };
}
exports.SearchedLibrary_ReleasesEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== '') {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.LibraryRelease.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchedLibrary_ReleasesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = exports.LibraryRelease.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : '',
            value: isSet(object.value)
                ? exports.LibraryRelease.fromJSON(object.value)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined &&
            (obj.value = message.value
                ? exports.LibraryRelease.toJSON(message.value)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.SearchedLibrary_ReleasesEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseSearchedLibrary_ReleasesEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : '';
        message.value =
            object.value !== undefined && object.value !== null
                ? exports.LibraryRelease.fromPartial(object.value)
                : undefined;
        return message;
    },
};
function createBaseLibraryRelease() {
    return {
        author: '',
        version: '',
        maintainer: '',
        sentence: '',
        paragraph: '',
        website: '',
        category: '',
        architectures: [],
        types: [],
        resources: undefined,
        license: '',
        providesIncludes: [],
        dependencies: [],
    };
}
exports.LibraryRelease = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.author !== '') {
            writer.uint32(10).string(message.author);
        }
        if (message.version !== '') {
            writer.uint32(18).string(message.version);
        }
        if (message.maintainer !== '') {
            writer.uint32(26).string(message.maintainer);
        }
        if (message.sentence !== '') {
            writer.uint32(34).string(message.sentence);
        }
        if (message.paragraph !== '') {
            writer.uint32(42).string(message.paragraph);
        }
        if (message.website !== '') {
            writer.uint32(50).string(message.website);
        }
        if (message.category !== '') {
            writer.uint32(58).string(message.category);
        }
        for (const v of message.architectures) {
            writer.uint32(66).string(v);
        }
        for (const v of message.types) {
            writer.uint32(74).string(v);
        }
        if (message.resources !== undefined) {
            exports.DownloadResource.encode(message.resources, writer.uint32(82).fork()).ldelim();
        }
        if (message.license !== '') {
            writer.uint32(90).string(message.license);
        }
        for (const v of message.providesIncludes) {
            writer.uint32(98).string(v);
        }
        for (const v of message.dependencies) {
            exports.LibraryDependency.encode(v, writer.uint32(106).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryRelease();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.author = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.maintainer = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.sentence = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.paragraph = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.website = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.category = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.architectures.push(reader.string());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.types.push(reader.string());
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.resources = exports.DownloadResource.decode(reader, reader.uint32());
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.license = reader.string();
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.providesIncludes.push(reader.string());
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.dependencies.push(exports.LibraryDependency.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            author: isSet(object.author) ? String(object.author) : '',
            version: isSet(object.version) ? String(object.version) : '',
            maintainer: isSet(object.maintainer)
                ? String(object.maintainer)
                : '',
            sentence: isSet(object.sentence) ? String(object.sentence) : '',
            paragraph: isSet(object.paragraph) ? String(object.paragraph) : '',
            website: isSet(object.website) ? String(object.website) : '',
            category: isSet(object.category) ? String(object.category) : '',
            architectures: Array.isArray(object === null || object === void 0 ? void 0 : object.architectures)
                ? object.architectures.map((e) => String(e))
                : [],
            types: Array.isArray(object === null || object === void 0 ? void 0 : object.types)
                ? object.types.map((e) => String(e))
                : [],
            resources: isSet(object.resources)
                ? exports.DownloadResource.fromJSON(object.resources)
                : undefined,
            license: isSet(object.license) ? String(object.license) : '',
            providesIncludes: Array.isArray(object === null || object === void 0 ? void 0 : object.providesIncludes)
                ? object.providesIncludes.map((e) => String(e))
                : [],
            dependencies: Array.isArray(object === null || object === void 0 ? void 0 : object.dependencies)
                ? object.dependencies.map((e) => exports.LibraryDependency.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.author !== undefined && (obj.author = message.author);
        message.version !== undefined && (obj.version = message.version);
        message.maintainer !== undefined &&
            (obj.maintainer = message.maintainer);
        message.sentence !== undefined && (obj.sentence = message.sentence);
        message.paragraph !== undefined && (obj.paragraph = message.paragraph);
        message.website !== undefined && (obj.website = message.website);
        message.category !== undefined && (obj.category = message.category);
        if (message.architectures) {
            obj.architectures = message.architectures.map((e) => e);
        }
        else {
            obj.architectures = [];
        }
        if (message.types) {
            obj.types = message.types.map((e) => e);
        }
        else {
            obj.types = [];
        }
        message.resources !== undefined &&
            (obj.resources = message.resources
                ? exports.DownloadResource.toJSON(message.resources)
                : undefined);
        message.license !== undefined && (obj.license = message.license);
        if (message.providesIncludes) {
            obj.providesIncludes = message.providesIncludes.map((e) => e);
        }
        else {
            obj.providesIncludes = [];
        }
        if (message.dependencies) {
            obj.dependencies = message.dependencies.map((e) => e ? exports.LibraryDependency.toJSON(e) : undefined);
        }
        else {
            obj.dependencies = [];
        }
        return obj;
    },
    create(base) {
        return exports.LibraryRelease.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const message = createBaseLibraryRelease();
        message.author = (_a = object.author) !== null && _a !== void 0 ? _a : '';
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : '';
        message.maintainer = (_c = object.maintainer) !== null && _c !== void 0 ? _c : '';
        message.sentence = (_d = object.sentence) !== null && _d !== void 0 ? _d : '';
        message.paragraph = (_e = object.paragraph) !== null && _e !== void 0 ? _e : '';
        message.website = (_f = object.website) !== null && _f !== void 0 ? _f : '';
        message.category = (_g = object.category) !== null && _g !== void 0 ? _g : '';
        message.architectures = ((_h = object.architectures) === null || _h === void 0 ? void 0 : _h.map((e) => e)) || [];
        message.types = ((_j = object.types) === null || _j === void 0 ? void 0 : _j.map((e) => e)) || [];
        message.resources =
            object.resources !== undefined && object.resources !== null
                ? exports.DownloadResource.fromPartial(object.resources)
                : undefined;
        message.license = (_k = object.license) !== null && _k !== void 0 ? _k : '';
        message.providesIncludes = ((_l = object.providesIncludes) === null || _l === void 0 ? void 0 : _l.map((e) => e)) || [];
        message.dependencies =
            ((_m = object.dependencies) === null || _m === void 0 ? void 0 : _m.map((e) => exports.LibraryDependency.fromPartial(e))) ||
                [];
        return message;
    },
};
function createBaseLibraryDependency() {
    return { name: '', versionConstraint: '' };
}
exports.LibraryDependency = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== '') {
            writer.uint32(10).string(message.name);
        }
        if (message.versionConstraint !== '') {
            writer.uint32(18).string(message.versionConstraint);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryDependency();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.versionConstraint = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : '',
            versionConstraint: isSet(object.versionConstraint)
                ? String(object.versionConstraint)
                : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.versionConstraint !== undefined &&
            (obj.versionConstraint = message.versionConstraint);
        return obj;
    },
    create(base) {
        return exports.LibraryDependency.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLibraryDependency();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : '';
        message.versionConstraint = (_b = object.versionConstraint) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseDownloadResource() {
    return {
        url: '',
        archiveFilename: '',
        checksum: '',
        size: 0,
        cachePath: '',
    };
}
exports.DownloadResource = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.url !== '') {
            writer.uint32(10).string(message.url);
        }
        if (message.archiveFilename !== '') {
            writer.uint32(18).string(message.archiveFilename);
        }
        if (message.checksum !== '') {
            writer.uint32(26).string(message.checksum);
        }
        if (message.size !== 0) {
            writer.uint32(32).int64(message.size);
        }
        if (message.cachePath !== '') {
            writer.uint32(42).string(message.cachePath);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDownloadResource();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.url = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.archiveFilename = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.checksum = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.size = longToNumber(reader.int64());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.cachePath = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            url: isSet(object.url) ? String(object.url) : '',
            archiveFilename: isSet(object.archiveFilename)
                ? String(object.archiveFilename)
                : '',
            checksum: isSet(object.checksum) ? String(object.checksum) : '',
            size: isSet(object.size) ? Number(object.size) : 0,
            cachePath: isSet(object.cachePath) ? String(object.cachePath) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.url !== undefined && (obj.url = message.url);
        message.archiveFilename !== undefined &&
            (obj.archiveFilename = message.archiveFilename);
        message.checksum !== undefined && (obj.checksum = message.checksum);
        message.size !== undefined && (obj.size = Math.round(message.size));
        message.cachePath !== undefined && (obj.cachePath = message.cachePath);
        return obj;
    },
    create(base) {
        return exports.DownloadResource.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseDownloadResource();
        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : '';
        message.archiveFilename = (_b = object.archiveFilename) !== null && _b !== void 0 ? _b : '';
        message.checksum = (_c = object.checksum) !== null && _c !== void 0 ? _c : '';
        message.size = (_d = object.size) !== null && _d !== void 0 ? _d : 0;
        message.cachePath = (_e = object.cachePath) !== null && _e !== void 0 ? _e : '';
        return message;
    },
};
function createBaseLibraryListRequest() {
    return {
        instance: undefined,
        all: false,
        updatable: false,
        name: '',
        fqbn: '',
    };
}
exports.LibraryListRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.all === true) {
            writer.uint32(16).bool(message.all);
        }
        if (message.updatable === true) {
            writer.uint32(24).bool(message.updatable);
        }
        if (message.name !== '') {
            writer.uint32(34).string(message.name);
        }
        if (message.fqbn !== '') {
            writer.uint32(42).string(message.fqbn);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryListRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.all = reader.bool();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.updatable = reader.bool();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.fqbn = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            all: isSet(object.all) ? Boolean(object.all) : false,
            updatable: isSet(object.updatable)
                ? Boolean(object.updatable)
                : false,
            name: isSet(object.name) ? String(object.name) : '',
            fqbn: isSet(object.fqbn) ? String(object.fqbn) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.all !== undefined && (obj.all = message.all);
        message.updatable !== undefined && (obj.updatable = message.updatable);
        message.name !== undefined && (obj.name = message.name);
        message.fqbn !== undefined && (obj.fqbn = message.fqbn);
        return obj;
    },
    create(base) {
        return exports.LibraryListRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseLibraryListRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.all = (_a = object.all) !== null && _a !== void 0 ? _a : false;
        message.updatable = (_b = object.updatable) !== null && _b !== void 0 ? _b : false;
        message.name = (_c = object.name) !== null && _c !== void 0 ? _c : '';
        message.fqbn = (_d = object.fqbn) !== null && _d !== void 0 ? _d : '';
        return message;
    },
};
function createBaseLibraryListResponse() {
    return { installedLibraries: [] };
}
exports.LibraryListResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.installedLibraries) {
            exports.InstalledLibrary.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibraryListResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.installedLibraries.push(exports.InstalledLibrary.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            installedLibraries: Array.isArray(object === null || object === void 0 ? void 0 : object.installedLibraries)
                ? object.installedLibraries.map((e) => exports.InstalledLibrary.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.installedLibraries) {
            obj.installedLibraries = message.installedLibraries.map((e) => e ? exports.InstalledLibrary.toJSON(e) : undefined);
        }
        else {
            obj.installedLibraries = [];
        }
        return obj;
    },
    create(base) {
        return exports.LibraryListResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseLibraryListResponse();
        message.installedLibraries =
            ((_a = object.installedLibraries) === null || _a === void 0 ? void 0 : _a.map((e) => exports.InstalledLibrary.fromPartial(e))) || [];
        return message;
    },
};
function createBaseInstalledLibrary() {
    return { library: undefined, release: undefined };
}
exports.InstalledLibrary = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.library !== undefined) {
            exports.Library.encode(message.library, writer.uint32(10).fork()).ldelim();
        }
        if (message.release !== undefined) {
            exports.LibraryRelease.encode(message.release, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstalledLibrary();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.library = exports.Library.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.release = exports.LibraryRelease.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            library: isSet(object.library)
                ? exports.Library.fromJSON(object.library)
                : undefined,
            release: isSet(object.release)
                ? exports.LibraryRelease.fromJSON(object.release)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.library !== undefined &&
            (obj.library = message.library
                ? exports.Library.toJSON(message.library)
                : undefined);
        message.release !== undefined &&
            (obj.release = message.release
                ? exports.LibraryRelease.toJSON(message.release)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.InstalledLibrary.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseInstalledLibrary();
        message.library =
            object.library !== undefined && object.library !== null
                ? exports.Library.fromPartial(object.library)
                : undefined;
        message.release =
            object.release !== undefined && object.release !== null
                ? exports.LibraryRelease.fromPartial(object.release)
                : undefined;
        return message;
    },
};
function createBaseLibrary() {
    return {
        name: '',
        author: '',
        maintainer: '',
        sentence: '',
        paragraph: '',
        website: '',
        category: '',
        architectures: [],
        types: [],
        installDir: '',
        sourceDir: '',
        utilityDir: '',
        containerPlatform: '',
        dotALinkage: false,
        precompiled: false,
        ldFlags: '',
        isLegacy: false,
        version: '',
        license: '',
        properties: {},
        location: 0,
        layout: 0,
        examples: [],
        providesIncludes: [],
        compatibleWith: {},
        inDevelopment: false,
    };
}
exports.Library = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== '') {
            writer.uint32(10).string(message.name);
        }
        if (message.author !== '') {
            writer.uint32(18).string(message.author);
        }
        if (message.maintainer !== '') {
            writer.uint32(26).string(message.maintainer);
        }
        if (message.sentence !== '') {
            writer.uint32(34).string(message.sentence);
        }
        if (message.paragraph !== '') {
            writer.uint32(42).string(message.paragraph);
        }
        if (message.website !== '') {
            writer.uint32(50).string(message.website);
        }
        if (message.category !== '') {
            writer.uint32(58).string(message.category);
        }
        for (const v of message.architectures) {
            writer.uint32(66).string(v);
        }
        for (const v of message.types) {
            writer.uint32(74).string(v);
        }
        if (message.installDir !== '') {
            writer.uint32(82).string(message.installDir);
        }
        if (message.sourceDir !== '') {
            writer.uint32(90).string(message.sourceDir);
        }
        if (message.utilityDir !== '') {
            writer.uint32(98).string(message.utilityDir);
        }
        if (message.containerPlatform !== '') {
            writer.uint32(114).string(message.containerPlatform);
        }
        if (message.dotALinkage === true) {
            writer.uint32(136).bool(message.dotALinkage);
        }
        if (message.precompiled === true) {
            writer.uint32(144).bool(message.precompiled);
        }
        if (message.ldFlags !== '') {
            writer.uint32(154).string(message.ldFlags);
        }
        if (message.isLegacy === true) {
            writer.uint32(160).bool(message.isLegacy);
        }
        if (message.version !== '') {
            writer.uint32(170).string(message.version);
        }
        if (message.license !== '') {
            writer.uint32(178).string(message.license);
        }
        Object.entries(message.properties).forEach(([key, value]) => {
            exports.Library_PropertiesEntry.encode({ key: key, value }, writer.uint32(186).fork()).ldelim();
        });
        if (message.location !== 0) {
            writer.uint32(192).int32(message.location);
        }
        if (message.layout !== 0) {
            writer.uint32(200).int32(message.layout);
        }
        for (const v of message.examples) {
            writer.uint32(210).string(v);
        }
        for (const v of message.providesIncludes) {
            writer.uint32(218).string(v);
        }
        Object.entries(message.compatibleWith).forEach(([key, value]) => {
            exports.Library_CompatibleWithEntry.encode({ key: key, value }, writer.uint32(226).fork()).ldelim();
        });
        if (message.inDevelopment === true) {
            writer.uint32(232).bool(message.inDevelopment);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibrary();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.author = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.maintainer = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.sentence = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.paragraph = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.website = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.category = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.architectures.push(reader.string());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.types.push(reader.string());
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.installDir = reader.string();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.sourceDir = reader.string();
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.utilityDir = reader.string();
                    continue;
                case 14:
                    if (tag !== 114) {
                        break;
                    }
                    message.containerPlatform = reader.string();
                    continue;
                case 17:
                    if (tag !== 136) {
                        break;
                    }
                    message.dotALinkage = reader.bool();
                    continue;
                case 18:
                    if (tag !== 144) {
                        break;
                    }
                    message.precompiled = reader.bool();
                    continue;
                case 19:
                    if (tag !== 154) {
                        break;
                    }
                    message.ldFlags = reader.string();
                    continue;
                case 20:
                    if (tag !== 160) {
                        break;
                    }
                    message.isLegacy = reader.bool();
                    continue;
                case 21:
                    if (tag !== 170) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                case 22:
                    if (tag !== 178) {
                        break;
                    }
                    message.license = reader.string();
                    continue;
                case 23:
                    if (tag !== 186) {
                        break;
                    }
                    const entry23 = exports.Library_PropertiesEntry.decode(reader, reader.uint32());
                    if (entry23.value !== undefined) {
                        message.properties[entry23.key] = entry23.value;
                    }
                    continue;
                case 24:
                    if (tag !== 192) {
                        break;
                    }
                    message.location = reader.int32();
                    continue;
                case 25:
                    if (tag !== 200) {
                        break;
                    }
                    message.layout = reader.int32();
                    continue;
                case 26:
                    if (tag !== 210) {
                        break;
                    }
                    message.examples.push(reader.string());
                    continue;
                case 27:
                    if (tag !== 218) {
                        break;
                    }
                    message.providesIncludes.push(reader.string());
                    continue;
                case 28:
                    if (tag !== 226) {
                        break;
                    }
                    const entry28 = exports.Library_CompatibleWithEntry.decode(reader, reader.uint32());
                    if (entry28.value !== undefined) {
                        message.compatibleWith[entry28.key] = entry28.value;
                    }
                    continue;
                case 29:
                    if (tag !== 232) {
                        break;
                    }
                    message.inDevelopment = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : '',
            author: isSet(object.author) ? String(object.author) : '',
            maintainer: isSet(object.maintainer)
                ? String(object.maintainer)
                : '',
            sentence: isSet(object.sentence) ? String(object.sentence) : '',
            paragraph: isSet(object.paragraph) ? String(object.paragraph) : '',
            website: isSet(object.website) ? String(object.website) : '',
            category: isSet(object.category) ? String(object.category) : '',
            architectures: Array.isArray(object === null || object === void 0 ? void 0 : object.architectures)
                ? object.architectures.map((e) => String(e))
                : [],
            types: Array.isArray(object === null || object === void 0 ? void 0 : object.types)
                ? object.types.map((e) => String(e))
                : [],
            installDir: isSet(object.installDir)
                ? String(object.installDir)
                : '',
            sourceDir: isSet(object.sourceDir) ? String(object.sourceDir) : '',
            utilityDir: isSet(object.utilityDir)
                ? String(object.utilityDir)
                : '',
            containerPlatform: isSet(object.containerPlatform)
                ? String(object.containerPlatform)
                : '',
            dotALinkage: isSet(object.dotALinkage)
                ? Boolean(object.dotALinkage)
                : false,
            precompiled: isSet(object.precompiled)
                ? Boolean(object.precompiled)
                : false,
            ldFlags: isSet(object.ldFlags) ? String(object.ldFlags) : '',
            isLegacy: isSet(object.isLegacy) ? Boolean(object.isLegacy) : false,
            version: isSet(object.version) ? String(object.version) : '',
            license: isSet(object.license) ? String(object.license) : '',
            properties: isObject(object.properties)
                ? Object.entries(object.properties).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            location: isSet(object.location)
                ? libraryLocationFromJSON(object.location)
                : 0,
            layout: isSet(object.layout)
                ? libraryLayoutFromJSON(object.layout)
                : 0,
            examples: Array.isArray(object === null || object === void 0 ? void 0 : object.examples)
                ? object.examples.map((e) => String(e))
                : [],
            providesIncludes: Array.isArray(object === null || object === void 0 ? void 0 : object.providesIncludes)
                ? object.providesIncludes.map((e) => String(e))
                : [],
            compatibleWith: isObject(object.compatibleWith)
                ? Object.entries(object.compatibleWith).reduce((acc, [key, value]) => {
                    acc[key] = Boolean(value);
                    return acc;
                }, {})
                : {},
            inDevelopment: isSet(object.inDevelopment)
                ? Boolean(object.inDevelopment)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.author !== undefined && (obj.author = message.author);
        message.maintainer !== undefined &&
            (obj.maintainer = message.maintainer);
        message.sentence !== undefined && (obj.sentence = message.sentence);
        message.paragraph !== undefined && (obj.paragraph = message.paragraph);
        message.website !== undefined && (obj.website = message.website);
        message.category !== undefined && (obj.category = message.category);
        if (message.architectures) {
            obj.architectures = message.architectures.map((e) => e);
        }
        else {
            obj.architectures = [];
        }
        if (message.types) {
            obj.types = message.types.map((e) => e);
        }
        else {
            obj.types = [];
        }
        message.installDir !== undefined &&
            (obj.installDir = message.installDir);
        message.sourceDir !== undefined && (obj.sourceDir = message.sourceDir);
        message.utilityDir !== undefined &&
            (obj.utilityDir = message.utilityDir);
        message.containerPlatform !== undefined &&
            (obj.containerPlatform = message.containerPlatform);
        message.dotALinkage !== undefined &&
            (obj.dotALinkage = message.dotALinkage);
        message.precompiled !== undefined &&
            (obj.precompiled = message.precompiled);
        message.ldFlags !== undefined && (obj.ldFlags = message.ldFlags);
        message.isLegacy !== undefined && (obj.isLegacy = message.isLegacy);
        message.version !== undefined && (obj.version = message.version);
        message.license !== undefined && (obj.license = message.license);
        obj.properties = {};
        if (message.properties) {
            Object.entries(message.properties).forEach(([k, v]) => {
                obj.properties[k] = v;
            });
        }
        message.location !== undefined &&
            (obj.location = libraryLocationToJSON(message.location));
        message.layout !== undefined &&
            (obj.layout = libraryLayoutToJSON(message.layout));
        if (message.examples) {
            obj.examples = message.examples.map((e) => e);
        }
        else {
            obj.examples = [];
        }
        if (message.providesIncludes) {
            obj.providesIncludes = message.providesIncludes.map((e) => e);
        }
        else {
            obj.providesIncludes = [];
        }
        obj.compatibleWith = {};
        if (message.compatibleWith) {
            Object.entries(message.compatibleWith).forEach(([k, v]) => {
                obj.compatibleWith[k] = v;
            });
        }
        message.inDevelopment !== undefined &&
            (obj.inDevelopment = message.inDevelopment);
        return obj;
    },
    create(base) {
        return exports.Library.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
        const message = createBaseLibrary();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : '';
        message.author = (_b = object.author) !== null && _b !== void 0 ? _b : '';
        message.maintainer = (_c = object.maintainer) !== null && _c !== void 0 ? _c : '';
        message.sentence = (_d = object.sentence) !== null && _d !== void 0 ? _d : '';
        message.paragraph = (_e = object.paragraph) !== null && _e !== void 0 ? _e : '';
        message.website = (_f = object.website) !== null && _f !== void 0 ? _f : '';
        message.category = (_g = object.category) !== null && _g !== void 0 ? _g : '';
        message.architectures = ((_h = object.architectures) === null || _h === void 0 ? void 0 : _h.map((e) => e)) || [];
        message.types = ((_j = object.types) === null || _j === void 0 ? void 0 : _j.map((e) => e)) || [];
        message.installDir = (_k = object.installDir) !== null && _k !== void 0 ? _k : '';
        message.sourceDir = (_l = object.sourceDir) !== null && _l !== void 0 ? _l : '';
        message.utilityDir = (_m = object.utilityDir) !== null && _m !== void 0 ? _m : '';
        message.containerPlatform = (_o = object.containerPlatform) !== null && _o !== void 0 ? _o : '';
        message.dotALinkage = (_p = object.dotALinkage) !== null && _p !== void 0 ? _p : false;
        message.precompiled = (_q = object.precompiled) !== null && _q !== void 0 ? _q : false;
        message.ldFlags = (_r = object.ldFlags) !== null && _r !== void 0 ? _r : '';
        message.isLegacy = (_s = object.isLegacy) !== null && _s !== void 0 ? _s : false;
        message.version = (_t = object.version) !== null && _t !== void 0 ? _t : '';
        message.license = (_u = object.license) !== null && _u !== void 0 ? _u : '';
        message.properties = Object.entries((_v = object.properties) !== null && _v !== void 0 ? _v : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        message.location = (_w = object.location) !== null && _w !== void 0 ? _w : 0;
        message.layout = (_x = object.layout) !== null && _x !== void 0 ? _x : 0;
        message.examples = ((_y = object.examples) === null || _y === void 0 ? void 0 : _y.map((e) => e)) || [];
        message.providesIncludes = ((_z = object.providesIncludes) === null || _z === void 0 ? void 0 : _z.map((e) => e)) || [];
        message.compatibleWith = Object.entries((_0 = object.compatibleWith) !== null && _0 !== void 0 ? _0 : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = Boolean(value);
            }
            return acc;
        }, {});
        message.inDevelopment = (_1 = object.inDevelopment) !== null && _1 !== void 0 ? _1 : false;
        return message;
    },
};
function createBaseLibrary_PropertiesEntry() {
    return { key: '', value: '' };
}
exports.Library_PropertiesEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== '') {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== '') {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibrary_PropertiesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : '',
            value: isSet(object.value) ? String(object.value) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    create(base) {
        return exports.Library_PropertiesEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLibrary_PropertiesEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : '';
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseLibrary_CompatibleWithEntry() {
    return { key: '', value: false };
}
exports.Library_CompatibleWithEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== '') {
            writer.uint32(10).string(message.key);
        }
        if (message.value === true) {
            writer.uint32(16).bool(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLibrary_CompatibleWithEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.value = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : '',
            value: isSet(object.value) ? Boolean(object.value) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    create(base) {
        return exports.Library_CompatibleWithEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLibrary_CompatibleWithEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : '';
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseZipLibraryInstallRequest() {
    return { instance: undefined, path: '', overwrite: false };
}
exports.ZipLibraryInstallRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.path !== '') {
            writer.uint32(18).string(message.path);
        }
        if (message.overwrite === true) {
            writer.uint32(24).bool(message.overwrite);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZipLibraryInstallRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.path = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.overwrite = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            path: isSet(object.path) ? String(object.path) : '',
            overwrite: isSet(object.overwrite)
                ? Boolean(object.overwrite)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.path !== undefined && (obj.path = message.path);
        message.overwrite !== undefined && (obj.overwrite = message.overwrite);
        return obj;
    },
    create(base) {
        return exports.ZipLibraryInstallRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseZipLibraryInstallRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.path = (_a = object.path) !== null && _a !== void 0 ? _a : '';
        message.overwrite = (_b = object.overwrite) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseZipLibraryInstallResponse() {
    return { taskProgress: undefined };
}
exports.ZipLibraryInstallResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.taskProgress !== undefined) {
            common_1.TaskProgress.encode(message.taskProgress, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseZipLibraryInstallResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.taskProgress = common_1.TaskProgress.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            taskProgress: isSet(object.taskProgress)
                ? common_1.TaskProgress.fromJSON(object.taskProgress)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.taskProgress !== undefined &&
            (obj.taskProgress = message.taskProgress
                ? common_1.TaskProgress.toJSON(message.taskProgress)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.ZipLibraryInstallResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseZipLibraryInstallResponse();
        message.taskProgress =
            object.taskProgress !== undefined && object.taskProgress !== null
                ? common_1.TaskProgress.fromPartial(object.taskProgress)
                : undefined;
        return message;
    },
};
function createBaseGitLibraryInstallRequest() {
    return { instance: undefined, url: '', overwrite: false };
}
exports.GitLibraryInstallRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.url !== '') {
            writer.uint32(18).string(message.url);
        }
        if (message.overwrite === true) {
            writer.uint32(24).bool(message.overwrite);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGitLibraryInstallRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.url = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.overwrite = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            url: isSet(object.url) ? String(object.url) : '',
            overwrite: isSet(object.overwrite)
                ? Boolean(object.overwrite)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.url !== undefined && (obj.url = message.url);
        message.overwrite !== undefined && (obj.overwrite = message.overwrite);
        return obj;
    },
    create(base) {
        return exports.GitLibraryInstallRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseGitLibraryInstallRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : '';
        message.overwrite = (_b = object.overwrite) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseGitLibraryInstallResponse() {
    return { taskProgress: undefined };
}
exports.GitLibraryInstallResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.taskProgress !== undefined) {
            common_1.TaskProgress.encode(message.taskProgress, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGitLibraryInstallResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.taskProgress = common_1.TaskProgress.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            taskProgress: isSet(object.taskProgress)
                ? common_1.TaskProgress.fromJSON(object.taskProgress)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.taskProgress !== undefined &&
            (obj.taskProgress = message.taskProgress
                ? common_1.TaskProgress.toJSON(message.taskProgress)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.GitLibraryInstallResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseGitLibraryInstallResponse();
        message.taskProgress =
            object.taskProgress !== undefined && object.taskProgress !== null
                ? common_1.TaskProgress.fromPartial(object.taskProgress)
                : undefined;
        return message;
    },
};
const tsProtoGlobalThis = (() => {
    if (typeof globalThis !== 'undefined') {
        return globalThis;
    }
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw 'Unable to locate global object';
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isObject(value) {
    return typeof value === 'object' && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
