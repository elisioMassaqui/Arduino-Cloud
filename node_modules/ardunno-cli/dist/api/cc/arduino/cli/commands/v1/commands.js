"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArduinoCoreServiceDefinition = exports.SetSketchDefaultsResponse = exports.SetSketchDefaultsRequest = exports.ArchiveSketchResponse = exports.ArchiveSketchRequest = exports.LoadSketchResponse = exports.SketchProfile = exports.LoadSketchRequest = exports.NewSketchResponse = exports.NewSketchRequest = exports.VersionResponse = exports.VersionRequest = exports.UpdateLibrariesIndexResponse = exports.UpdateLibrariesIndexRequest = exports.UpdateIndexResponse = exports.UpdateIndexRequest = exports.DestroyResponse = exports.DestroyRequest = exports.FailedInstanceInitError = exports.InitResponse_Progress = exports.InitResponse = exports.InitRequest = exports.CreateResponse = exports.CreateRequest = exports.failedInstanceInitReasonToJSON = exports.failedInstanceInitReasonFromJSON = exports.FailedInstanceInitReason = void 0;
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const status_1 = require("../../../../../google/rpc/status");
const board_1 = require("./board");
const common_1 = require("./common");
const compile_1 = require("./compile");
const core_1 = require("./core");
const debug_1 = require("./debug");
const lib_1 = require("./lib");
const monitor_1 = require("./monitor");
const upload_1 = require("./upload");
var FailedInstanceInitReason;
(function (FailedInstanceInitReason) {
    /** FAILED_INSTANCE_INIT_REASON_UNSPECIFIED - FAILED_INSTANCE_INIT_REASON_UNSPECIFIED the error reason is not specialized */
    FailedInstanceInitReason[FailedInstanceInitReason["FAILED_INSTANCE_INIT_REASON_UNSPECIFIED"] = 0] = "FAILED_INSTANCE_INIT_REASON_UNSPECIFIED";
    /** FAILED_INSTANCE_INIT_REASON_INVALID_INDEX_URL - INVALID_INDEX_URL a package index url is malformed */
    FailedInstanceInitReason[FailedInstanceInitReason["FAILED_INSTANCE_INIT_REASON_INVALID_INDEX_URL"] = 1] = "FAILED_INSTANCE_INIT_REASON_INVALID_INDEX_URL";
    /**
     * FAILED_INSTANCE_INIT_REASON_INDEX_LOAD_ERROR - FAILED_INSTANCE_INIT_REASON_INDEX_LOAD_ERROR failure encountered while
     * loading an index
     */
    FailedInstanceInitReason[FailedInstanceInitReason["FAILED_INSTANCE_INIT_REASON_INDEX_LOAD_ERROR"] = 2] = "FAILED_INSTANCE_INIT_REASON_INDEX_LOAD_ERROR";
    /**
     * FAILED_INSTANCE_INIT_REASON_TOOL_LOAD_ERROR - FAILED_INSTANCE_INIT_REASON_TOOL_LOAD_ERROR failure encountered while
     * loading a tool
     */
    FailedInstanceInitReason[FailedInstanceInitReason["FAILED_INSTANCE_INIT_REASON_TOOL_LOAD_ERROR"] = 3] = "FAILED_INSTANCE_INIT_REASON_TOOL_LOAD_ERROR";
    /**
     * FAILED_INSTANCE_INIT_REASON_INDEX_DOWNLOAD_ERROR - FAILED_INSTANCE_INIT_REASON_INDEX_DOWNLOAD_ERROR failure encountered while
     * downloading an index
     */
    FailedInstanceInitReason[FailedInstanceInitReason["FAILED_INSTANCE_INIT_REASON_INDEX_DOWNLOAD_ERROR"] = 4] = "FAILED_INSTANCE_INIT_REASON_INDEX_DOWNLOAD_ERROR";
    FailedInstanceInitReason[FailedInstanceInitReason["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FailedInstanceInitReason = exports.FailedInstanceInitReason || (exports.FailedInstanceInitReason = {}));
function failedInstanceInitReasonFromJSON(object) {
    switch (object) {
        case 0:
        case 'FAILED_INSTANCE_INIT_REASON_UNSPECIFIED':
            return FailedInstanceInitReason.FAILED_INSTANCE_INIT_REASON_UNSPECIFIED;
        case 1:
        case 'FAILED_INSTANCE_INIT_REASON_INVALID_INDEX_URL':
            return FailedInstanceInitReason.FAILED_INSTANCE_INIT_REASON_INVALID_INDEX_URL;
        case 2:
        case 'FAILED_INSTANCE_INIT_REASON_INDEX_LOAD_ERROR':
            return FailedInstanceInitReason.FAILED_INSTANCE_INIT_REASON_INDEX_LOAD_ERROR;
        case 3:
        case 'FAILED_INSTANCE_INIT_REASON_TOOL_LOAD_ERROR':
            return FailedInstanceInitReason.FAILED_INSTANCE_INIT_REASON_TOOL_LOAD_ERROR;
        case 4:
        case 'FAILED_INSTANCE_INIT_REASON_INDEX_DOWNLOAD_ERROR':
            return FailedInstanceInitReason.FAILED_INSTANCE_INIT_REASON_INDEX_DOWNLOAD_ERROR;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return FailedInstanceInitReason.UNRECOGNIZED;
    }
}
exports.failedInstanceInitReasonFromJSON = failedInstanceInitReasonFromJSON;
function failedInstanceInitReasonToJSON(object) {
    switch (object) {
        case FailedInstanceInitReason.FAILED_INSTANCE_INIT_REASON_UNSPECIFIED:
            return 'FAILED_INSTANCE_INIT_REASON_UNSPECIFIED';
        case FailedInstanceInitReason.FAILED_INSTANCE_INIT_REASON_INVALID_INDEX_URL:
            return 'FAILED_INSTANCE_INIT_REASON_INVALID_INDEX_URL';
        case FailedInstanceInitReason.FAILED_INSTANCE_INIT_REASON_INDEX_LOAD_ERROR:
            return 'FAILED_INSTANCE_INIT_REASON_INDEX_LOAD_ERROR';
        case FailedInstanceInitReason.FAILED_INSTANCE_INIT_REASON_TOOL_LOAD_ERROR:
            return 'FAILED_INSTANCE_INIT_REASON_TOOL_LOAD_ERROR';
        case FailedInstanceInitReason.FAILED_INSTANCE_INIT_REASON_INDEX_DOWNLOAD_ERROR:
            return 'FAILED_INSTANCE_INIT_REASON_INDEX_DOWNLOAD_ERROR';
        case FailedInstanceInitReason.UNRECOGNIZED:
        default:
            return 'UNRECOGNIZED';
    }
}
exports.failedInstanceInitReasonToJSON = failedInstanceInitReasonToJSON;
function createBaseCreateRequest() {
    return {};
}
exports.CreateRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.CreateRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseCreateRequest();
        return message;
    },
};
function createBaseCreateResponse() {
    return { instance: undefined };
}
exports.CreateResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.CreateResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseCreateResponse();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        return message;
    },
};
function createBaseInitRequest() {
    return { instance: undefined, profile: '', sketchPath: '' };
}
exports.InitRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.profile !== '') {
            writer.uint32(18).string(message.profile);
        }
        if (message.sketchPath !== '') {
            writer.uint32(26).string(message.sketchPath);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInitRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.profile = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.sketchPath = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            profile: isSet(object.profile) ? String(object.profile) : '',
            sketchPath: isSet(object.sketchPath)
                ? String(object.sketchPath)
                : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.profile !== undefined && (obj.profile = message.profile);
        message.sketchPath !== undefined &&
            (obj.sketchPath = message.sketchPath);
        return obj;
    },
    create(base) {
        return exports.InitRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseInitRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.profile = (_a = object.profile) !== null && _a !== void 0 ? _a : '';
        message.sketchPath = (_b = object.sketchPath) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseInitResponse() {
    return { message: undefined };
}
exports.InitResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        var _a;
        switch ((_a = message.message) === null || _a === void 0 ? void 0 : _a.$case) {
            case 'initProgress':
                exports.InitResponse_Progress.encode(message.message.initProgress, writer.uint32(10).fork()).ldelim();
                break;
            case 'error':
                status_1.Status.encode(message.message.error, writer.uint32(18).fork()).ldelim();
                break;
            case 'profile':
                common_1.Profile.encode(message.message.profile, writer.uint32(26).fork()).ldelim();
                break;
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInitResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.message = {
                        $case: 'initProgress',
                        initProgress: exports.InitResponse_Progress.decode(reader, reader.uint32()),
                    };
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = {
                        $case: 'error',
                        error: status_1.Status.decode(reader, reader.uint32()),
                    };
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.message = {
                        $case: 'profile',
                        profile: common_1.Profile.decode(reader, reader.uint32()),
                    };
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            message: isSet(object.initProgress)
                ? {
                    $case: 'initProgress',
                    initProgress: exports.InitResponse_Progress.fromJSON(object.initProgress),
                }
                : isSet(object.error)
                    ? { $case: 'error', error: status_1.Status.fromJSON(object.error) }
                    : isSet(object.profile)
                        ? {
                            $case: 'profile',
                            profile: common_1.Profile.fromJSON(object.profile),
                        }
                        : undefined,
        };
    },
    toJSON(message) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const obj = {};
        ((_a = message.message) === null || _a === void 0 ? void 0 : _a.$case) === 'initProgress' &&
            (obj.initProgress = ((_b = message.message) === null || _b === void 0 ? void 0 : _b.initProgress)
                ? exports.InitResponse_Progress.toJSON((_c = message.message) === null || _c === void 0 ? void 0 : _c.initProgress)
                : undefined);
        ((_d = message.message) === null || _d === void 0 ? void 0 : _d.$case) === 'error' &&
            (obj.error = ((_e = message.message) === null || _e === void 0 ? void 0 : _e.error)
                ? status_1.Status.toJSON((_f = message.message) === null || _f === void 0 ? void 0 : _f.error)
                : undefined);
        ((_g = message.message) === null || _g === void 0 ? void 0 : _g.$case) === 'profile' &&
            (obj.profile = ((_h = message.message) === null || _h === void 0 ? void 0 : _h.profile)
                ? common_1.Profile.toJSON((_j = message.message) === null || _j === void 0 ? void 0 : _j.profile)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.InitResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseInitResponse();
        if (((_a = object.message) === null || _a === void 0 ? void 0 : _a.$case) === 'initProgress' &&
            ((_b = object.message) === null || _b === void 0 ? void 0 : _b.initProgress) !== undefined &&
            ((_c = object.message) === null || _c === void 0 ? void 0 : _c.initProgress) !== null) {
            message.message = {
                $case: 'initProgress',
                initProgress: exports.InitResponse_Progress.fromPartial(object.message.initProgress),
            };
        }
        if (((_d = object.message) === null || _d === void 0 ? void 0 : _d.$case) === 'error' &&
            ((_e = object.message) === null || _e === void 0 ? void 0 : _e.error) !== undefined &&
            ((_f = object.message) === null || _f === void 0 ? void 0 : _f.error) !== null) {
            message.message = {
                $case: 'error',
                error: status_1.Status.fromPartial(object.message.error),
            };
        }
        if (((_g = object.message) === null || _g === void 0 ? void 0 : _g.$case) === 'profile' &&
            ((_h = object.message) === null || _h === void 0 ? void 0 : _h.profile) !== undefined &&
            ((_j = object.message) === null || _j === void 0 ? void 0 : _j.profile) !== null) {
            message.message = {
                $case: 'profile',
                profile: common_1.Profile.fromPartial(object.message.profile),
            };
        }
        return message;
    },
};
function createBaseInitResponse_Progress() {
    return { downloadProgress: undefined, taskProgress: undefined };
}
exports.InitResponse_Progress = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.downloadProgress !== undefined) {
            common_1.DownloadProgress.encode(message.downloadProgress, writer.uint32(10).fork()).ldelim();
        }
        if (message.taskProgress !== undefined) {
            common_1.TaskProgress.encode(message.taskProgress, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInitResponse_Progress();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.downloadProgress = common_1.DownloadProgress.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.taskProgress = common_1.TaskProgress.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            downloadProgress: isSet(object.downloadProgress)
                ? common_1.DownloadProgress.fromJSON(object.downloadProgress)
                : undefined,
            taskProgress: isSet(object.taskProgress)
                ? common_1.TaskProgress.fromJSON(object.taskProgress)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.downloadProgress !== undefined &&
            (obj.downloadProgress = message.downloadProgress
                ? common_1.DownloadProgress.toJSON(message.downloadProgress)
                : undefined);
        message.taskProgress !== undefined &&
            (obj.taskProgress = message.taskProgress
                ? common_1.TaskProgress.toJSON(message.taskProgress)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.InitResponse_Progress.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseInitResponse_Progress();
        message.downloadProgress =
            object.downloadProgress !== undefined &&
                object.downloadProgress !== null
                ? common_1.DownloadProgress.fromPartial(object.downloadProgress)
                : undefined;
        message.taskProgress =
            object.taskProgress !== undefined && object.taskProgress !== null
                ? common_1.TaskProgress.fromPartial(object.taskProgress)
                : undefined;
        return message;
    },
};
function createBaseFailedInstanceInitError() {
    return { reason: 0, message: '' };
}
exports.FailedInstanceInitError = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.reason !== 0) {
            writer.uint32(8).int32(message.reason);
        }
        if (message.message !== '') {
            writer.uint32(18).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFailedInstanceInitError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.reason = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            reason: isSet(object.reason)
                ? failedInstanceInitReasonFromJSON(object.reason)
                : 0,
            message: isSet(object.message) ? String(object.message) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.reason !== undefined &&
            (obj.reason = failedInstanceInitReasonToJSON(message.reason));
        message.message !== undefined && (obj.message = message.message);
        return obj;
    },
    create(base) {
        return exports.FailedInstanceInitError.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseFailedInstanceInitError();
        message.reason = (_a = object.reason) !== null && _a !== void 0 ? _a : 0;
        message.message = (_b = object.message) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseDestroyRequest() {
    return { instance: undefined };
}
exports.DestroyRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDestroyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.DestroyRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseDestroyRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        return message;
    },
};
function createBaseDestroyResponse() {
    return {};
}
exports.DestroyResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDestroyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.DestroyResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseDestroyResponse();
        return message;
    },
};
function createBaseUpdateIndexRequest() {
    return { instance: undefined, ignoreCustomPackageIndexes: false };
}
exports.UpdateIndexRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.ignoreCustomPackageIndexes === true) {
            writer.uint32(16).bool(message.ignoreCustomPackageIndexes);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateIndexRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.ignoreCustomPackageIndexes = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            ignoreCustomPackageIndexes: isSet(object.ignoreCustomPackageIndexes)
                ? Boolean(object.ignoreCustomPackageIndexes)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.ignoreCustomPackageIndexes !== undefined &&
            (obj.ignoreCustomPackageIndexes =
                message.ignoreCustomPackageIndexes);
        return obj;
    },
    create(base) {
        return exports.UpdateIndexRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseUpdateIndexRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.ignoreCustomPackageIndexes =
            (_a = object.ignoreCustomPackageIndexes) !== null && _a !== void 0 ? _a : false;
        return message;
    },
};
function createBaseUpdateIndexResponse() {
    return { downloadProgress: undefined };
}
exports.UpdateIndexResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.downloadProgress !== undefined) {
            common_1.DownloadProgress.encode(message.downloadProgress, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateIndexResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.downloadProgress = common_1.DownloadProgress.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            downloadProgress: isSet(object.downloadProgress)
                ? common_1.DownloadProgress.fromJSON(object.downloadProgress)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.downloadProgress !== undefined &&
            (obj.downloadProgress = message.downloadProgress
                ? common_1.DownloadProgress.toJSON(message.downloadProgress)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.UpdateIndexResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseUpdateIndexResponse();
        message.downloadProgress =
            object.downloadProgress !== undefined &&
                object.downloadProgress !== null
                ? common_1.DownloadProgress.fromPartial(object.downloadProgress)
                : undefined;
        return message;
    },
};
function createBaseUpdateLibrariesIndexRequest() {
    return { instance: undefined };
}
exports.UpdateLibrariesIndexRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateLibrariesIndexRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.UpdateLibrariesIndexRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseUpdateLibrariesIndexRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        return message;
    },
};
function createBaseUpdateLibrariesIndexResponse() {
    return { downloadProgress: undefined };
}
exports.UpdateLibrariesIndexResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.downloadProgress !== undefined) {
            common_1.DownloadProgress.encode(message.downloadProgress, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateLibrariesIndexResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.downloadProgress = common_1.DownloadProgress.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            downloadProgress: isSet(object.downloadProgress)
                ? common_1.DownloadProgress.fromJSON(object.downloadProgress)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.downloadProgress !== undefined &&
            (obj.downloadProgress = message.downloadProgress
                ? common_1.DownloadProgress.toJSON(message.downloadProgress)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.UpdateLibrariesIndexResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseUpdateLibrariesIndexResponse();
        message.downloadProgress =
            object.downloadProgress !== undefined &&
                object.downloadProgress !== null
                ? common_1.DownloadProgress.fromPartial(object.downloadProgress)
                : undefined;
        return message;
    },
};
function createBaseVersionRequest() {
    return {};
}
exports.VersionRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVersionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.VersionRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseVersionRequest();
        return message;
    },
};
function createBaseVersionResponse() {
    return { version: '' };
}
exports.VersionResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.version !== '') {
            writer.uint32(10).string(message.version);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVersionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { version: isSet(object.version) ? String(object.version) : '' };
    },
    toJSON(message) {
        const obj = {};
        message.version !== undefined && (obj.version = message.version);
        return obj;
    },
    create(base) {
        return exports.VersionResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseVersionResponse();
        message.version = (_a = object.version) !== null && _a !== void 0 ? _a : '';
        return message;
    },
};
function createBaseNewSketchRequest() {
    return { sketchName: '', sketchDir: '', overwrite: false };
}
exports.NewSketchRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sketchName !== '') {
            writer.uint32(18).string(message.sketchName);
        }
        if (message.sketchDir !== '') {
            writer.uint32(26).string(message.sketchDir);
        }
        if (message.overwrite === true) {
            writer.uint32(32).bool(message.overwrite);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNewSketchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.sketchName = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.sketchDir = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.overwrite = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sketchName: isSet(object.sketchName)
                ? String(object.sketchName)
                : '',
            sketchDir: isSet(object.sketchDir) ? String(object.sketchDir) : '',
            overwrite: isSet(object.overwrite)
                ? Boolean(object.overwrite)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sketchName !== undefined &&
            (obj.sketchName = message.sketchName);
        message.sketchDir !== undefined && (obj.sketchDir = message.sketchDir);
        message.overwrite !== undefined && (obj.overwrite = message.overwrite);
        return obj;
    },
    create(base) {
        return exports.NewSketchRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseNewSketchRequest();
        message.sketchName = (_a = object.sketchName) !== null && _a !== void 0 ? _a : '';
        message.sketchDir = (_b = object.sketchDir) !== null && _b !== void 0 ? _b : '';
        message.overwrite = (_c = object.overwrite) !== null && _c !== void 0 ? _c : false;
        return message;
    },
};
function createBaseNewSketchResponse() {
    return { mainFile: '' };
}
exports.NewSketchResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mainFile !== '') {
            writer.uint32(10).string(message.mainFile);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNewSketchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.mainFile = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            mainFile: isSet(object.mainFile) ? String(object.mainFile) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.mainFile !== undefined && (obj.mainFile = message.mainFile);
        return obj;
    },
    create(base) {
        return exports.NewSketchResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseNewSketchResponse();
        message.mainFile = (_a = object.mainFile) !== null && _a !== void 0 ? _a : '';
        return message;
    },
};
function createBaseLoadSketchRequest() {
    return { sketchPath: '' };
}
exports.LoadSketchRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sketchPath !== '') {
            writer.uint32(18).string(message.sketchPath);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLoadSketchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.sketchPath = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sketchPath: isSet(object.sketchPath)
                ? String(object.sketchPath)
                : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.sketchPath !== undefined &&
            (obj.sketchPath = message.sketchPath);
        return obj;
    },
    create(base) {
        return exports.LoadSketchRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseLoadSketchRequest();
        message.sketchPath = (_a = object.sketchPath) !== null && _a !== void 0 ? _a : '';
        return message;
    },
};
function createBaseSketchProfile() {
    return { name: '', fqbn: '' };
}
exports.SketchProfile = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== '') {
            writer.uint32(10).string(message.name);
        }
        if (message.fqbn !== '') {
            writer.uint32(18).string(message.fqbn);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSketchProfile();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fqbn = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : '',
            fqbn: isSet(object.fqbn) ? String(object.fqbn) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.fqbn !== undefined && (obj.fqbn = message.fqbn);
        return obj;
    },
    create(base) {
        return exports.SketchProfile.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSketchProfile();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : '';
        message.fqbn = (_b = object.fqbn) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseLoadSketchResponse() {
    return {
        mainFile: '',
        locationPath: '',
        otherSketchFiles: [],
        additionalFiles: [],
        rootFolderFiles: [],
        defaultFqbn: '',
        defaultPort: '',
        defaultProtocol: '',
        profiles: [],
        defaultProfile: undefined,
    };
}
exports.LoadSketchResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mainFile !== '') {
            writer.uint32(10).string(message.mainFile);
        }
        if (message.locationPath !== '') {
            writer.uint32(18).string(message.locationPath);
        }
        for (const v of message.otherSketchFiles) {
            writer.uint32(26).string(v);
        }
        for (const v of message.additionalFiles) {
            writer.uint32(34).string(v);
        }
        for (const v of message.rootFolderFiles) {
            writer.uint32(42).string(v);
        }
        if (message.defaultFqbn !== '') {
            writer.uint32(50).string(message.defaultFqbn);
        }
        if (message.defaultPort !== '') {
            writer.uint32(58).string(message.defaultPort);
        }
        if (message.defaultProtocol !== '') {
            writer.uint32(66).string(message.defaultProtocol);
        }
        for (const v of message.profiles) {
            exports.SketchProfile.encode(v, writer.uint32(74).fork()).ldelim();
        }
        if (message.defaultProfile !== undefined) {
            exports.SketchProfile.encode(message.defaultProfile, writer.uint32(82).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLoadSketchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.mainFile = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.locationPath = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.otherSketchFiles.push(reader.string());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.additionalFiles.push(reader.string());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.rootFolderFiles.push(reader.string());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.defaultFqbn = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.defaultPort = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.defaultProtocol = reader.string();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.profiles.push(exports.SketchProfile.decode(reader, reader.uint32()));
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.defaultProfile = exports.SketchProfile.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            mainFile: isSet(object.mainFile) ? String(object.mainFile) : '',
            locationPath: isSet(object.locationPath)
                ? String(object.locationPath)
                : '',
            otherSketchFiles: Array.isArray(object === null || object === void 0 ? void 0 : object.otherSketchFiles)
                ? object.otherSketchFiles.map((e) => String(e))
                : [],
            additionalFiles: Array.isArray(object === null || object === void 0 ? void 0 : object.additionalFiles)
                ? object.additionalFiles.map((e) => String(e))
                : [],
            rootFolderFiles: Array.isArray(object === null || object === void 0 ? void 0 : object.rootFolderFiles)
                ? object.rootFolderFiles.map((e) => String(e))
                : [],
            defaultFqbn: isSet(object.defaultFqbn)
                ? String(object.defaultFqbn)
                : '',
            defaultPort: isSet(object.defaultPort)
                ? String(object.defaultPort)
                : '',
            defaultProtocol: isSet(object.defaultProtocol)
                ? String(object.defaultProtocol)
                : '',
            profiles: Array.isArray(object === null || object === void 0 ? void 0 : object.profiles)
                ? object.profiles.map((e) => exports.SketchProfile.fromJSON(e))
                : [],
            defaultProfile: isSet(object.defaultProfile)
                ? exports.SketchProfile.fromJSON(object.defaultProfile)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.mainFile !== undefined && (obj.mainFile = message.mainFile);
        message.locationPath !== undefined &&
            (obj.locationPath = message.locationPath);
        if (message.otherSketchFiles) {
            obj.otherSketchFiles = message.otherSketchFiles.map((e) => e);
        }
        else {
            obj.otherSketchFiles = [];
        }
        if (message.additionalFiles) {
            obj.additionalFiles = message.additionalFiles.map((e) => e);
        }
        else {
            obj.additionalFiles = [];
        }
        if (message.rootFolderFiles) {
            obj.rootFolderFiles = message.rootFolderFiles.map((e) => e);
        }
        else {
            obj.rootFolderFiles = [];
        }
        message.defaultFqbn !== undefined &&
            (obj.defaultFqbn = message.defaultFqbn);
        message.defaultPort !== undefined &&
            (obj.defaultPort = message.defaultPort);
        message.defaultProtocol !== undefined &&
            (obj.defaultProtocol = message.defaultProtocol);
        if (message.profiles) {
            obj.profiles = message.profiles.map((e) => e ? exports.SketchProfile.toJSON(e) : undefined);
        }
        else {
            obj.profiles = [];
        }
        message.defaultProfile !== undefined &&
            (obj.defaultProfile = message.defaultProfile
                ? exports.SketchProfile.toJSON(message.defaultProfile)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.LoadSketchResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseLoadSketchResponse();
        message.mainFile = (_a = object.mainFile) !== null && _a !== void 0 ? _a : '';
        message.locationPath = (_b = object.locationPath) !== null && _b !== void 0 ? _b : '';
        message.otherSketchFiles = ((_c = object.otherSketchFiles) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.additionalFiles = ((_d = object.additionalFiles) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        message.rootFolderFiles = ((_e = object.rootFolderFiles) === null || _e === void 0 ? void 0 : _e.map((e) => e)) || [];
        message.defaultFqbn = (_f = object.defaultFqbn) !== null && _f !== void 0 ? _f : '';
        message.defaultPort = (_g = object.defaultPort) !== null && _g !== void 0 ? _g : '';
        message.defaultProtocol = (_h = object.defaultProtocol) !== null && _h !== void 0 ? _h : '';
        message.profiles =
            ((_j = object.profiles) === null || _j === void 0 ? void 0 : _j.map((e) => exports.SketchProfile.fromPartial(e))) || [];
        message.defaultProfile =
            object.defaultProfile !== undefined &&
                object.defaultProfile !== null
                ? exports.SketchProfile.fromPartial(object.defaultProfile)
                : undefined;
        return message;
    },
};
function createBaseArchiveSketchRequest() {
    return {
        sketchPath: '',
        archivePath: '',
        includeBuildDir: false,
        overwrite: false,
    };
}
exports.ArchiveSketchRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sketchPath !== '') {
            writer.uint32(10).string(message.sketchPath);
        }
        if (message.archivePath !== '') {
            writer.uint32(18).string(message.archivePath);
        }
        if (message.includeBuildDir === true) {
            writer.uint32(24).bool(message.includeBuildDir);
        }
        if (message.overwrite === true) {
            writer.uint32(32).bool(message.overwrite);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseArchiveSketchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sketchPath = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.archivePath = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.includeBuildDir = reader.bool();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.overwrite = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sketchPath: isSet(object.sketchPath)
                ? String(object.sketchPath)
                : '',
            archivePath: isSet(object.archivePath)
                ? String(object.archivePath)
                : '',
            includeBuildDir: isSet(object.includeBuildDir)
                ? Boolean(object.includeBuildDir)
                : false,
            overwrite: isSet(object.overwrite)
                ? Boolean(object.overwrite)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sketchPath !== undefined &&
            (obj.sketchPath = message.sketchPath);
        message.archivePath !== undefined &&
            (obj.archivePath = message.archivePath);
        message.includeBuildDir !== undefined &&
            (obj.includeBuildDir = message.includeBuildDir);
        message.overwrite !== undefined && (obj.overwrite = message.overwrite);
        return obj;
    },
    create(base) {
        return exports.ArchiveSketchRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseArchiveSketchRequest();
        message.sketchPath = (_a = object.sketchPath) !== null && _a !== void 0 ? _a : '';
        message.archivePath = (_b = object.archivePath) !== null && _b !== void 0 ? _b : '';
        message.includeBuildDir = (_c = object.includeBuildDir) !== null && _c !== void 0 ? _c : false;
        message.overwrite = (_d = object.overwrite) !== null && _d !== void 0 ? _d : false;
        return message;
    },
};
function createBaseArchiveSketchResponse() {
    return {};
}
exports.ArchiveSketchResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseArchiveSketchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.ArchiveSketchResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseArchiveSketchResponse();
        return message;
    },
};
function createBaseSetSketchDefaultsRequest() {
    return {
        sketchPath: '',
        defaultFqbn: '',
        defaultPortAddress: '',
        defaultPortProtocol: '',
    };
}
exports.SetSketchDefaultsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sketchPath !== '') {
            writer.uint32(10).string(message.sketchPath);
        }
        if (message.defaultFqbn !== '') {
            writer.uint32(18).string(message.defaultFqbn);
        }
        if (message.defaultPortAddress !== '') {
            writer.uint32(26).string(message.defaultPortAddress);
        }
        if (message.defaultPortProtocol !== '') {
            writer.uint32(34).string(message.defaultPortProtocol);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetSketchDefaultsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sketchPath = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.defaultFqbn = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.defaultPortAddress = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.defaultPortProtocol = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sketchPath: isSet(object.sketchPath)
                ? String(object.sketchPath)
                : '',
            defaultFqbn: isSet(object.defaultFqbn)
                ? String(object.defaultFqbn)
                : '',
            defaultPortAddress: isSet(object.defaultPortAddress)
                ? String(object.defaultPortAddress)
                : '',
            defaultPortProtocol: isSet(object.defaultPortProtocol)
                ? String(object.defaultPortProtocol)
                : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.sketchPath !== undefined &&
            (obj.sketchPath = message.sketchPath);
        message.defaultFqbn !== undefined &&
            (obj.defaultFqbn = message.defaultFqbn);
        message.defaultPortAddress !== undefined &&
            (obj.defaultPortAddress = message.defaultPortAddress);
        message.defaultPortProtocol !== undefined &&
            (obj.defaultPortProtocol = message.defaultPortProtocol);
        return obj;
    },
    create(base) {
        return exports.SetSketchDefaultsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseSetSketchDefaultsRequest();
        message.sketchPath = (_a = object.sketchPath) !== null && _a !== void 0 ? _a : '';
        message.defaultFqbn = (_b = object.defaultFqbn) !== null && _b !== void 0 ? _b : '';
        message.defaultPortAddress = (_c = object.defaultPortAddress) !== null && _c !== void 0 ? _c : '';
        message.defaultPortProtocol = (_d = object.defaultPortProtocol) !== null && _d !== void 0 ? _d : '';
        return message;
    },
};
function createBaseSetSketchDefaultsResponse() {
    return { defaultFqbn: '', defaultPortAddress: '', defaultPortProtocol: '' };
}
exports.SetSketchDefaultsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.defaultFqbn !== '') {
            writer.uint32(10).string(message.defaultFqbn);
        }
        if (message.defaultPortAddress !== '') {
            writer.uint32(18).string(message.defaultPortAddress);
        }
        if (message.defaultPortProtocol !== '') {
            writer.uint32(26).string(message.defaultPortProtocol);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetSketchDefaultsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.defaultFqbn = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.defaultPortAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.defaultPortProtocol = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            defaultFqbn: isSet(object.defaultFqbn)
                ? String(object.defaultFqbn)
                : '',
            defaultPortAddress: isSet(object.defaultPortAddress)
                ? String(object.defaultPortAddress)
                : '',
            defaultPortProtocol: isSet(object.defaultPortProtocol)
                ? String(object.defaultPortProtocol)
                : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.defaultFqbn !== undefined &&
            (obj.defaultFqbn = message.defaultFqbn);
        message.defaultPortAddress !== undefined &&
            (obj.defaultPortAddress = message.defaultPortAddress);
        message.defaultPortProtocol !== undefined &&
            (obj.defaultPortProtocol = message.defaultPortProtocol);
        return obj;
    },
    create(base) {
        return exports.SetSketchDefaultsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSetSketchDefaultsResponse();
        message.defaultFqbn = (_a = object.defaultFqbn) !== null && _a !== void 0 ? _a : '';
        message.defaultPortAddress = (_b = object.defaultPortAddress) !== null && _b !== void 0 ? _b : '';
        message.defaultPortProtocol = (_c = object.defaultPortProtocol) !== null && _c !== void 0 ? _c : '';
        return message;
    },
};
exports.ArduinoCoreServiceDefinition = {
    name: 'ArduinoCoreService',
    fullName: 'cc.arduino.cli.commands.v1.ArduinoCoreService',
    methods: {
        /** Create a new Arduino Core instance */
        create: {
            name: 'Create',
            requestType: exports.CreateRequest,
            requestStream: false,
            responseType: exports.CreateResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Initializes an existing Arduino Core instance by loading platforms and
         * libraries
         */
        init: {
            name: 'Init',
            requestType: exports.InitRequest,
            requestStream: false,
            responseType: exports.InitResponse,
            responseStream: true,
            options: {},
        },
        /** Destroy an instance of the Arduino Core Service */
        destroy: {
            name: 'Destroy',
            requestType: exports.DestroyRequest,
            requestStream: false,
            responseType: exports.DestroyResponse,
            responseStream: false,
            options: {},
        },
        /** Update package index of the Arduino Core Service */
        updateIndex: {
            name: 'UpdateIndex',
            requestType: exports.UpdateIndexRequest,
            requestStream: false,
            responseType: exports.UpdateIndexResponse,
            responseStream: true,
            options: {},
        },
        /** Update libraries index */
        updateLibrariesIndex: {
            name: 'UpdateLibrariesIndex',
            requestType: exports.UpdateLibrariesIndexRequest,
            requestStream: false,
            responseType: exports.UpdateLibrariesIndexResponse,
            responseStream: true,
            options: {},
        },
        /** Get the version of Arduino CLI in use. */
        version: {
            name: 'Version',
            requestType: exports.VersionRequest,
            requestStream: false,
            responseType: exports.VersionResponse,
            responseStream: false,
            options: {},
        },
        /** Create a new Sketch */
        newSketch: {
            name: 'NewSketch',
            requestType: exports.NewSketchRequest,
            requestStream: false,
            responseType: exports.NewSketchResponse,
            responseStream: false,
            options: {},
        },
        /** Returns all files composing a Sketch */
        loadSketch: {
            name: 'LoadSketch',
            requestType: exports.LoadSketchRequest,
            requestStream: false,
            responseType: exports.LoadSketchResponse,
            responseStream: false,
            options: {},
        },
        /** Creates a zip file containing all files of specified Sketch */
        archiveSketch: {
            name: 'ArchiveSketch',
            requestType: exports.ArchiveSketchRequest,
            requestStream: false,
            responseType: exports.ArchiveSketchResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Sets the sketch default FQBN and Port Address/Protocol in
         * the sketch project file (sketch.yaml). These metadata can be retrieved
         * using LoadSketch.
         */
        setSketchDefaults: {
            name: 'SetSketchDefaults',
            requestType: exports.SetSketchDefaultsRequest,
            requestStream: false,
            responseType: exports.SetSketchDefaultsResponse,
            responseStream: false,
            options: {},
        },
        /** Requests details about a board */
        boardDetails: {
            name: 'BoardDetails',
            requestType: board_1.BoardDetailsRequest,
            requestStream: false,
            responseType: board_1.BoardDetailsResponse,
            responseStream: false,
            options: {},
        },
        /** List the boards currently connected to the computer. */
        boardList: {
            name: 'BoardList',
            requestType: board_1.BoardListRequest,
            requestStream: false,
            responseType: board_1.BoardListResponse,
            responseStream: false,
            options: {},
        },
        /** List all the boards provided by installed platforms. */
        boardListAll: {
            name: 'BoardListAll',
            requestType: board_1.BoardListAllRequest,
            requestStream: false,
            responseType: board_1.BoardListAllResponse,
            responseStream: false,
            options: {},
        },
        /** Search boards in installed and not installed Platforms. */
        boardSearch: {
            name: 'BoardSearch',
            requestType: board_1.BoardSearchRequest,
            requestStream: false,
            responseType: board_1.BoardSearchResponse,
            responseStream: false,
            options: {},
        },
        /** List boards connection and disconnected events. */
        boardListWatch: {
            name: 'BoardListWatch',
            requestType: board_1.BoardListWatchRequest,
            requestStream: false,
            responseType: board_1.BoardListWatchResponse,
            responseStream: true,
            options: {},
        },
        /** Compile an Arduino sketch. */
        compile: {
            name: 'Compile',
            requestType: compile_1.CompileRequest,
            requestStream: false,
            responseType: compile_1.CompileResponse,
            responseStream: true,
            options: {},
        },
        /** Download and install a platform and its tool dependencies. */
        platformInstall: {
            name: 'PlatformInstall',
            requestType: core_1.PlatformInstallRequest,
            requestStream: false,
            responseType: core_1.PlatformInstallResponse,
            responseStream: true,
            options: {},
        },
        /**
         * Download a platform and its tool dependencies to the `staging/packages`
         * subdirectory of the data directory.
         */
        platformDownload: {
            name: 'PlatformDownload',
            requestType: core_1.PlatformDownloadRequest,
            requestStream: false,
            responseType: core_1.PlatformDownloadResponse,
            responseStream: true,
            options: {},
        },
        /**
         * Uninstall a platform as well as its tool dependencies that are not used by
         * other installed platforms.
         */
        platformUninstall: {
            name: 'PlatformUninstall',
            requestType: core_1.PlatformUninstallRequest,
            requestStream: false,
            responseType: core_1.PlatformUninstallResponse,
            responseStream: true,
            options: {},
        },
        /** Upgrade an installed platform to the latest version. */
        platformUpgrade: {
            name: 'PlatformUpgrade',
            requestType: core_1.PlatformUpgradeRequest,
            requestStream: false,
            responseType: core_1.PlatformUpgradeResponse,
            responseStream: true,
            options: {},
        },
        /** Upload a compiled sketch to a board. */
        upload: {
            name: 'Upload',
            requestType: upload_1.UploadRequest,
            requestStream: false,
            responseType: upload_1.UploadResponse,
            responseStream: true,
            options: {},
        },
        /** Upload a compiled sketch to a board using a programmer. */
        uploadUsingProgrammer: {
            name: 'UploadUsingProgrammer',
            requestType: upload_1.UploadUsingProgrammerRequest,
            requestStream: false,
            responseType: upload_1.UploadUsingProgrammerResponse,
            responseStream: true,
            options: {},
        },
        /**
         * Returns the list of users fields necessary to upload to that board
         * using the specified protocol.
         */
        supportedUserFields: {
            name: 'SupportedUserFields',
            requestType: upload_1.SupportedUserFieldsRequest,
            requestStream: false,
            responseType: upload_1.SupportedUserFieldsResponse,
            responseStream: false,
            options: {},
        },
        /** List programmers available for a board. */
        listProgrammersAvailableForUpload: {
            name: 'ListProgrammersAvailableForUpload',
            requestType: upload_1.ListProgrammersAvailableForUploadRequest,
            requestStream: false,
            responseType: upload_1.ListProgrammersAvailableForUploadResponse,
            responseStream: false,
            options: {},
        },
        /** Burn bootloader to a board. */
        burnBootloader: {
            name: 'BurnBootloader',
            requestType: upload_1.BurnBootloaderRequest,
            requestStream: false,
            responseType: upload_1.BurnBootloaderResponse,
            responseStream: true,
            options: {},
        },
        /** Search for a platform in the platforms indexes. */
        platformSearch: {
            name: 'PlatformSearch',
            requestType: core_1.PlatformSearchRequest,
            requestStream: false,
            responseType: core_1.PlatformSearchResponse,
            responseStream: false,
            options: {},
        },
        /** List all installed platforms. */
        platformList: {
            name: 'PlatformList',
            requestType: core_1.PlatformListRequest,
            requestStream: false,
            responseType: core_1.PlatformListResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Download the archive file of an Arduino library in the libraries index to
         * the staging directory.
         */
        libraryDownload: {
            name: 'LibraryDownload',
            requestType: lib_1.LibraryDownloadRequest,
            requestStream: false,
            responseType: lib_1.LibraryDownloadResponse,
            responseStream: true,
            options: {},
        },
        /** Download and install an Arduino library from the libraries index. */
        libraryInstall: {
            name: 'LibraryInstall',
            requestType: lib_1.LibraryInstallRequest,
            requestStream: false,
            responseType: lib_1.LibraryInstallResponse,
            responseStream: true,
            options: {},
        },
        /** Upgrade a library to the newest version available. */
        libraryUpgrade: {
            name: 'LibraryUpgrade',
            requestType: lib_1.LibraryUpgradeRequest,
            requestStream: false,
            responseType: lib_1.LibraryUpgradeResponse,
            responseStream: true,
            options: {},
        },
        /** Install a library from a Zip File */
        zipLibraryInstall: {
            name: 'ZipLibraryInstall',
            requestType: lib_1.ZipLibraryInstallRequest,
            requestStream: false,
            responseType: lib_1.ZipLibraryInstallResponse,
            responseStream: true,
            options: {},
        },
        /** Download and install a library from a git url */
        gitLibraryInstall: {
            name: 'GitLibraryInstall',
            requestType: lib_1.GitLibraryInstallRequest,
            requestStream: false,
            responseType: lib_1.GitLibraryInstallResponse,
            responseStream: true,
            options: {},
        },
        /** Uninstall an Arduino library. */
        libraryUninstall: {
            name: 'LibraryUninstall',
            requestType: lib_1.LibraryUninstallRequest,
            requestStream: false,
            responseType: lib_1.LibraryUninstallResponse,
            responseStream: true,
            options: {},
        },
        /** Upgrade all installed Arduino libraries to the newest version available. */
        libraryUpgradeAll: {
            name: 'LibraryUpgradeAll',
            requestType: lib_1.LibraryUpgradeAllRequest,
            requestStream: false,
            responseType: lib_1.LibraryUpgradeAllResponse,
            responseStream: true,
            options: {},
        },
        /**
         * List the recursive dependencies of a library, as defined by the `depends`
         * field of the library.properties files.
         */
        libraryResolveDependencies: {
            name: 'LibraryResolveDependencies',
            requestType: lib_1.LibraryResolveDependenciesRequest,
            requestStream: false,
            responseType: lib_1.LibraryResolveDependenciesResponse,
            responseStream: false,
            options: {},
        },
        /** Search the Arduino libraries index for libraries. */
        librarySearch: {
            name: 'LibrarySearch',
            requestType: lib_1.LibrarySearchRequest,
            requestStream: false,
            responseType: lib_1.LibrarySearchResponse,
            responseStream: false,
            options: {},
        },
        /** List the installed libraries. */
        libraryList: {
            name: 'LibraryList',
            requestType: lib_1.LibraryListRequest,
            requestStream: false,
            responseType: lib_1.LibraryListResponse,
            responseStream: false,
            options: {},
        },
        /** Open a monitor connection to a board port */
        monitor: {
            name: 'Monitor',
            requestType: monitor_1.MonitorRequest,
            requestStream: true,
            responseType: monitor_1.MonitorResponse,
            responseStream: true,
            options: {},
        },
        /** Returns the parameters that can be set in the MonitorRequest calls */
        enumerateMonitorPortSettings: {
            name: 'EnumerateMonitorPortSettings',
            requestType: monitor_1.EnumerateMonitorPortSettingsRequest,
            requestStream: false,
            responseType: monitor_1.EnumerateMonitorPortSettingsResponse,
            responseStream: false,
            options: {},
        },
        /** Start a debug session and communicate with the debugger tool. */
        debug: {
            name: 'Debug',
            requestType: debug_1.DebugRequest,
            requestStream: true,
            responseType: debug_1.DebugResponse,
            responseStream: true,
            options: {},
        },
        /** Determine if debugging is suported given a specific configuration. */
        isDebugSupported: {
            name: 'IsDebugSupported',
            requestType: debug_1.IsDebugSupportedRequest,
            requestStream: false,
            responseType: debug_1.IsDebugSupportedResponse,
            responseStream: false,
            options: {},
        },
        /** Query the debugger information given a specific configuration. */
        getDebugConfig: {
            name: 'GetDebugConfig',
            requestType: debug_1.GetDebugConfigRequest,
            requestStream: false,
            responseType: debug_1.GetDebugConfigResponse,
            responseStream: false,
            options: {},
        },
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
