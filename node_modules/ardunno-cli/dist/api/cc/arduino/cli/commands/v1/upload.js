"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SupportedUserFieldsResponse = exports.UserField = exports.SupportedUserFieldsRequest = exports.ListProgrammersAvailableForUploadResponse = exports.ListProgrammersAvailableForUploadRequest = exports.BurnBootloaderResponse = exports.BurnBootloaderRequest_UserFieldsEntry = exports.BurnBootloaderRequest = exports.UploadUsingProgrammerResponse = exports.UploadUsingProgrammerRequest_UserFieldsEntry = exports.UploadUsingProgrammerRequest = exports.ProgrammerIsRequiredForUploadError = exports.UploadResult = exports.UploadResponse = exports.UploadRequest_UserFieldsEntry = exports.UploadRequest = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const common_1 = require("./common");
const port_1 = require("./port");
function createBaseUploadRequest() {
    return {
        instance: undefined,
        fqbn: '',
        sketchPath: '',
        port: undefined,
        verbose: false,
        verify: false,
        importFile: '',
        importDir: '',
        programmer: '',
        dryRun: false,
        userFields: {},
    };
}
exports.UploadRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.fqbn !== '') {
            writer.uint32(18).string(message.fqbn);
        }
        if (message.sketchPath !== '') {
            writer.uint32(26).string(message.sketchPath);
        }
        if (message.port !== undefined) {
            port_1.Port.encode(message.port, writer.uint32(34).fork()).ldelim();
        }
        if (message.verbose === true) {
            writer.uint32(40).bool(message.verbose);
        }
        if (message.verify === true) {
            writer.uint32(48).bool(message.verify);
        }
        if (message.importFile !== '') {
            writer.uint32(58).string(message.importFile);
        }
        if (message.importDir !== '') {
            writer.uint32(66).string(message.importDir);
        }
        if (message.programmer !== '') {
            writer.uint32(74).string(message.programmer);
        }
        if (message.dryRun === true) {
            writer.uint32(80).bool(message.dryRun);
        }
        Object.entries(message.userFields).forEach(([key, value]) => {
            exports.UploadRequest_UserFieldsEntry.encode({ key: key, value }, writer.uint32(90).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fqbn = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.sketchPath = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.port = port_1.Port.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.verbose = reader.bool();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.verify = reader.bool();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.importFile = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.importDir = reader.string();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.programmer = reader.string();
                    continue;
                case 10:
                    if (tag !== 80) {
                        break;
                    }
                    message.dryRun = reader.bool();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    const entry11 = exports.UploadRequest_UserFieldsEntry.decode(reader, reader.uint32());
                    if (entry11.value !== undefined) {
                        message.userFields[entry11.key] = entry11.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            fqbn: isSet(object.fqbn) ? String(object.fqbn) : '',
            sketchPath: isSet(object.sketchPath)
                ? String(object.sketchPath)
                : '',
            port: isSet(object.port) ? port_1.Port.fromJSON(object.port) : undefined,
            verbose: isSet(object.verbose) ? Boolean(object.verbose) : false,
            verify: isSet(object.verify) ? Boolean(object.verify) : false,
            importFile: isSet(object.importFile)
                ? String(object.importFile)
                : '',
            importDir: isSet(object.importDir) ? String(object.importDir) : '',
            programmer: isSet(object.programmer)
                ? String(object.programmer)
                : '',
            dryRun: isSet(object.dryRun) ? Boolean(object.dryRun) : false,
            userFields: isObject(object.userFields)
                ? Object.entries(object.userFields).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.fqbn !== undefined && (obj.fqbn = message.fqbn);
        message.sketchPath !== undefined &&
            (obj.sketchPath = message.sketchPath);
        message.port !== undefined &&
            (obj.port = message.port ? port_1.Port.toJSON(message.port) : undefined);
        message.verbose !== undefined && (obj.verbose = message.verbose);
        message.verify !== undefined && (obj.verify = message.verify);
        message.importFile !== undefined &&
            (obj.importFile = message.importFile);
        message.importDir !== undefined && (obj.importDir = message.importDir);
        message.programmer !== undefined &&
            (obj.programmer = message.programmer);
        message.dryRun !== undefined && (obj.dryRun = message.dryRun);
        obj.userFields = {};
        if (message.userFields) {
            Object.entries(message.userFields).forEach(([k, v]) => {
                obj.userFields[k] = v;
            });
        }
        return obj;
    },
    create(base) {
        return exports.UploadRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseUploadRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.fqbn = (_a = object.fqbn) !== null && _a !== void 0 ? _a : '';
        message.sketchPath = (_b = object.sketchPath) !== null && _b !== void 0 ? _b : '';
        message.port =
            object.port !== undefined && object.port !== null
                ? port_1.Port.fromPartial(object.port)
                : undefined;
        message.verbose = (_c = object.verbose) !== null && _c !== void 0 ? _c : false;
        message.verify = (_d = object.verify) !== null && _d !== void 0 ? _d : false;
        message.importFile = (_e = object.importFile) !== null && _e !== void 0 ? _e : '';
        message.importDir = (_f = object.importDir) !== null && _f !== void 0 ? _f : '';
        message.programmer = (_g = object.programmer) !== null && _g !== void 0 ? _g : '';
        message.dryRun = (_h = object.dryRun) !== null && _h !== void 0 ? _h : false;
        message.userFields = Object.entries((_j = object.userFields) !== null && _j !== void 0 ? _j : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseUploadRequest_UserFieldsEntry() {
    return { key: '', value: '' };
}
exports.UploadRequest_UserFieldsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== '') {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== '') {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadRequest_UserFieldsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : '',
            value: isSet(object.value) ? String(object.value) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    create(base) {
        return exports.UploadRequest_UserFieldsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseUploadRequest_UserFieldsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : '';
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseUploadResponse() {
    return { message: undefined };
}
exports.UploadResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        var _a;
        switch ((_a = message.message) === null || _a === void 0 ? void 0 : _a.$case) {
            case 'outStream':
                writer.uint32(10).bytes(message.message.outStream);
                break;
            case 'errStream':
                writer.uint32(18).bytes(message.message.errStream);
                break;
            case 'result':
                exports.UploadResult.encode(message.message.result, writer.uint32(26).fork()).ldelim();
                break;
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.message = {
                        $case: 'outStream',
                        outStream: reader.bytes(),
                    };
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = {
                        $case: 'errStream',
                        errStream: reader.bytes(),
                    };
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.message = {
                        $case: 'result',
                        result: exports.UploadResult.decode(reader, reader.uint32()),
                    };
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            message: isSet(object.outStream)
                ? {
                    $case: 'outStream',
                    outStream: bytesFromBase64(object.outStream),
                }
                : isSet(object.errStream)
                    ? {
                        $case: 'errStream',
                        errStream: bytesFromBase64(object.errStream),
                    }
                    : isSet(object.result)
                        ? {
                            $case: 'result',
                            result: exports.UploadResult.fromJSON(object.result),
                        }
                        : undefined,
        };
    },
    toJSON(message) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const obj = {};
        ((_a = message.message) === null || _a === void 0 ? void 0 : _a.$case) === 'outStream' &&
            (obj.outStream =
                ((_b = message.message) === null || _b === void 0 ? void 0 : _b.outStream) !== undefined
                    ? base64FromBytes((_c = message.message) === null || _c === void 0 ? void 0 : _c.outStream)
                    : undefined);
        ((_d = message.message) === null || _d === void 0 ? void 0 : _d.$case) === 'errStream' &&
            (obj.errStream =
                ((_e = message.message) === null || _e === void 0 ? void 0 : _e.errStream) !== undefined
                    ? base64FromBytes((_f = message.message) === null || _f === void 0 ? void 0 : _f.errStream)
                    : undefined);
        ((_g = message.message) === null || _g === void 0 ? void 0 : _g.$case) === 'result' &&
            (obj.result = ((_h = message.message) === null || _h === void 0 ? void 0 : _h.result)
                ? exports.UploadResult.toJSON((_j = message.message) === null || _j === void 0 ? void 0 : _j.result)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.UploadResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseUploadResponse();
        if (((_a = object.message) === null || _a === void 0 ? void 0 : _a.$case) === 'outStream' &&
            ((_b = object.message) === null || _b === void 0 ? void 0 : _b.outStream) !== undefined &&
            ((_c = object.message) === null || _c === void 0 ? void 0 : _c.outStream) !== null) {
            message.message = {
                $case: 'outStream',
                outStream: object.message.outStream,
            };
        }
        if (((_d = object.message) === null || _d === void 0 ? void 0 : _d.$case) === 'errStream' &&
            ((_e = object.message) === null || _e === void 0 ? void 0 : _e.errStream) !== undefined &&
            ((_f = object.message) === null || _f === void 0 ? void 0 : _f.errStream) !== null) {
            message.message = {
                $case: 'errStream',
                errStream: object.message.errStream,
            };
        }
        if (((_g = object.message) === null || _g === void 0 ? void 0 : _g.$case) === 'result' &&
            ((_h = object.message) === null || _h === void 0 ? void 0 : _h.result) !== undefined &&
            ((_j = object.message) === null || _j === void 0 ? void 0 : _j.result) !== null) {
            message.message = {
                $case: 'result',
                result: exports.UploadResult.fromPartial(object.message.result),
            };
        }
        return message;
    },
};
function createBaseUploadResult() {
    return { updatedUploadPort: undefined };
}
exports.UploadResult = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.updatedUploadPort !== undefined) {
            port_1.Port.encode(message.updatedUploadPort, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.updatedUploadPort = port_1.Port.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            updatedUploadPort: isSet(object.updatedUploadPort)
                ? port_1.Port.fromJSON(object.updatedUploadPort)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.updatedUploadPort !== undefined &&
            (obj.updatedUploadPort = message.updatedUploadPort
                ? port_1.Port.toJSON(message.updatedUploadPort)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.UploadResult.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseUploadResult();
        message.updatedUploadPort =
            object.updatedUploadPort !== undefined &&
                object.updatedUploadPort !== null
                ? port_1.Port.fromPartial(object.updatedUploadPort)
                : undefined;
        return message;
    },
};
function createBaseProgrammerIsRequiredForUploadError() {
    return {};
}
exports.ProgrammerIsRequiredForUploadError = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProgrammerIsRequiredForUploadError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.ProgrammerIsRequiredForUploadError.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseProgrammerIsRequiredForUploadError();
        return message;
    },
};
function createBaseUploadUsingProgrammerRequest() {
    return {
        instance: undefined,
        fqbn: '',
        sketchPath: '',
        port: undefined,
        verbose: false,
        verify: false,
        importFile: '',
        importDir: '',
        programmer: '',
        dryRun: false,
        userFields: {},
    };
}
exports.UploadUsingProgrammerRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.fqbn !== '') {
            writer.uint32(18).string(message.fqbn);
        }
        if (message.sketchPath !== '') {
            writer.uint32(26).string(message.sketchPath);
        }
        if (message.port !== undefined) {
            port_1.Port.encode(message.port, writer.uint32(34).fork()).ldelim();
        }
        if (message.verbose === true) {
            writer.uint32(40).bool(message.verbose);
        }
        if (message.verify === true) {
            writer.uint32(48).bool(message.verify);
        }
        if (message.importFile !== '') {
            writer.uint32(58).string(message.importFile);
        }
        if (message.importDir !== '') {
            writer.uint32(66).string(message.importDir);
        }
        if (message.programmer !== '') {
            writer.uint32(74).string(message.programmer);
        }
        if (message.dryRun === true) {
            writer.uint32(80).bool(message.dryRun);
        }
        Object.entries(message.userFields).forEach(([key, value]) => {
            exports.UploadUsingProgrammerRequest_UserFieldsEntry.encode({ key: key, value }, writer.uint32(90).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadUsingProgrammerRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fqbn = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.sketchPath = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.port = port_1.Port.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.verbose = reader.bool();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.verify = reader.bool();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.importFile = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.importDir = reader.string();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.programmer = reader.string();
                    continue;
                case 10:
                    if (tag !== 80) {
                        break;
                    }
                    message.dryRun = reader.bool();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    const entry11 = exports.UploadUsingProgrammerRequest_UserFieldsEntry.decode(reader, reader.uint32());
                    if (entry11.value !== undefined) {
                        message.userFields[entry11.key] = entry11.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            fqbn: isSet(object.fqbn) ? String(object.fqbn) : '',
            sketchPath: isSet(object.sketchPath)
                ? String(object.sketchPath)
                : '',
            port: isSet(object.port) ? port_1.Port.fromJSON(object.port) : undefined,
            verbose: isSet(object.verbose) ? Boolean(object.verbose) : false,
            verify: isSet(object.verify) ? Boolean(object.verify) : false,
            importFile: isSet(object.importFile)
                ? String(object.importFile)
                : '',
            importDir: isSet(object.importDir) ? String(object.importDir) : '',
            programmer: isSet(object.programmer)
                ? String(object.programmer)
                : '',
            dryRun: isSet(object.dryRun) ? Boolean(object.dryRun) : false,
            userFields: isObject(object.userFields)
                ? Object.entries(object.userFields).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.fqbn !== undefined && (obj.fqbn = message.fqbn);
        message.sketchPath !== undefined &&
            (obj.sketchPath = message.sketchPath);
        message.port !== undefined &&
            (obj.port = message.port ? port_1.Port.toJSON(message.port) : undefined);
        message.verbose !== undefined && (obj.verbose = message.verbose);
        message.verify !== undefined && (obj.verify = message.verify);
        message.importFile !== undefined &&
            (obj.importFile = message.importFile);
        message.importDir !== undefined && (obj.importDir = message.importDir);
        message.programmer !== undefined &&
            (obj.programmer = message.programmer);
        message.dryRun !== undefined && (obj.dryRun = message.dryRun);
        obj.userFields = {};
        if (message.userFields) {
            Object.entries(message.userFields).forEach(([k, v]) => {
                obj.userFields[k] = v;
            });
        }
        return obj;
    },
    create(base) {
        return exports.UploadUsingProgrammerRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseUploadUsingProgrammerRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.fqbn = (_a = object.fqbn) !== null && _a !== void 0 ? _a : '';
        message.sketchPath = (_b = object.sketchPath) !== null && _b !== void 0 ? _b : '';
        message.port =
            object.port !== undefined && object.port !== null
                ? port_1.Port.fromPartial(object.port)
                : undefined;
        message.verbose = (_c = object.verbose) !== null && _c !== void 0 ? _c : false;
        message.verify = (_d = object.verify) !== null && _d !== void 0 ? _d : false;
        message.importFile = (_e = object.importFile) !== null && _e !== void 0 ? _e : '';
        message.importDir = (_f = object.importDir) !== null && _f !== void 0 ? _f : '';
        message.programmer = (_g = object.programmer) !== null && _g !== void 0 ? _g : '';
        message.dryRun = (_h = object.dryRun) !== null && _h !== void 0 ? _h : false;
        message.userFields = Object.entries((_j = object.userFields) !== null && _j !== void 0 ? _j : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseUploadUsingProgrammerRequest_UserFieldsEntry() {
    return { key: '', value: '' };
}
exports.UploadUsingProgrammerRequest_UserFieldsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== '') {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== '') {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadUsingProgrammerRequest_UserFieldsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : '',
            value: isSet(object.value) ? String(object.value) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    create(base) {
        return exports.UploadUsingProgrammerRequest_UserFieldsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseUploadUsingProgrammerRequest_UserFieldsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : '';
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseUploadUsingProgrammerResponse() {
    return { outStream: new Uint8Array(0), errStream: new Uint8Array(0) };
}
exports.UploadUsingProgrammerResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.outStream.length !== 0) {
            writer.uint32(10).bytes(message.outStream);
        }
        if (message.errStream.length !== 0) {
            writer.uint32(18).bytes(message.errStream);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadUsingProgrammerResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.outStream = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.errStream = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            outStream: isSet(object.outStream)
                ? bytesFromBase64(object.outStream)
                : new Uint8Array(0),
            errStream: isSet(object.errStream)
                ? bytesFromBase64(object.errStream)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        message.outStream !== undefined &&
            (obj.outStream = base64FromBytes(message.outStream !== undefined
                ? message.outStream
                : new Uint8Array(0)));
        message.errStream !== undefined &&
            (obj.errStream = base64FromBytes(message.errStream !== undefined
                ? message.errStream
                : new Uint8Array(0)));
        return obj;
    },
    create(base) {
        return exports.UploadUsingProgrammerResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseUploadUsingProgrammerResponse();
        message.outStream = (_a = object.outStream) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.errStream = (_b = object.errStream) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        return message;
    },
};
function createBaseBurnBootloaderRequest() {
    return {
        instance: undefined,
        fqbn: '',
        port: undefined,
        verbose: false,
        verify: false,
        programmer: '',
        dryRun: false,
        userFields: {},
    };
}
exports.BurnBootloaderRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.fqbn !== '') {
            writer.uint32(18).string(message.fqbn);
        }
        if (message.port !== undefined) {
            port_1.Port.encode(message.port, writer.uint32(26).fork()).ldelim();
        }
        if (message.verbose === true) {
            writer.uint32(32).bool(message.verbose);
        }
        if (message.verify === true) {
            writer.uint32(40).bool(message.verify);
        }
        if (message.programmer !== '') {
            writer.uint32(50).string(message.programmer);
        }
        if (message.dryRun === true) {
            writer.uint32(56).bool(message.dryRun);
        }
        Object.entries(message.userFields).forEach(([key, value]) => {
            exports.BurnBootloaderRequest_UserFieldsEntry.encode({ key: key, value }, writer.uint32(90).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBurnBootloaderRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fqbn = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.port = port_1.Port.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.verbose = reader.bool();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.verify = reader.bool();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.programmer = reader.string();
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.dryRun = reader.bool();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    const entry11 = exports.BurnBootloaderRequest_UserFieldsEntry.decode(reader, reader.uint32());
                    if (entry11.value !== undefined) {
                        message.userFields[entry11.key] = entry11.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            fqbn: isSet(object.fqbn) ? String(object.fqbn) : '',
            port: isSet(object.port) ? port_1.Port.fromJSON(object.port) : undefined,
            verbose: isSet(object.verbose) ? Boolean(object.verbose) : false,
            verify: isSet(object.verify) ? Boolean(object.verify) : false,
            programmer: isSet(object.programmer)
                ? String(object.programmer)
                : '',
            dryRun: isSet(object.dryRun) ? Boolean(object.dryRun) : false,
            userFields: isObject(object.userFields)
                ? Object.entries(object.userFields).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.fqbn !== undefined && (obj.fqbn = message.fqbn);
        message.port !== undefined &&
            (obj.port = message.port ? port_1.Port.toJSON(message.port) : undefined);
        message.verbose !== undefined && (obj.verbose = message.verbose);
        message.verify !== undefined && (obj.verify = message.verify);
        message.programmer !== undefined &&
            (obj.programmer = message.programmer);
        message.dryRun !== undefined && (obj.dryRun = message.dryRun);
        obj.userFields = {};
        if (message.userFields) {
            Object.entries(message.userFields).forEach(([k, v]) => {
                obj.userFields[k] = v;
            });
        }
        return obj;
    },
    create(base) {
        return exports.BurnBootloaderRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseBurnBootloaderRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.fqbn = (_a = object.fqbn) !== null && _a !== void 0 ? _a : '';
        message.port =
            object.port !== undefined && object.port !== null
                ? port_1.Port.fromPartial(object.port)
                : undefined;
        message.verbose = (_b = object.verbose) !== null && _b !== void 0 ? _b : false;
        message.verify = (_c = object.verify) !== null && _c !== void 0 ? _c : false;
        message.programmer = (_d = object.programmer) !== null && _d !== void 0 ? _d : '';
        message.dryRun = (_e = object.dryRun) !== null && _e !== void 0 ? _e : false;
        message.userFields = Object.entries((_f = object.userFields) !== null && _f !== void 0 ? _f : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseBurnBootloaderRequest_UserFieldsEntry() {
    return { key: '', value: '' };
}
exports.BurnBootloaderRequest_UserFieldsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== '') {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== '') {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBurnBootloaderRequest_UserFieldsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? String(object.key) : '',
            value: isSet(object.value) ? String(object.value) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    create(base) {
        return exports.BurnBootloaderRequest_UserFieldsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseBurnBootloaderRequest_UserFieldsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : '';
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseBurnBootloaderResponse() {
    return { outStream: new Uint8Array(0), errStream: new Uint8Array(0) };
}
exports.BurnBootloaderResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.outStream.length !== 0) {
            writer.uint32(10).bytes(message.outStream);
        }
        if (message.errStream.length !== 0) {
            writer.uint32(18).bytes(message.errStream);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBurnBootloaderResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.outStream = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.errStream = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            outStream: isSet(object.outStream)
                ? bytesFromBase64(object.outStream)
                : new Uint8Array(0),
            errStream: isSet(object.errStream)
                ? bytesFromBase64(object.errStream)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        message.outStream !== undefined &&
            (obj.outStream = base64FromBytes(message.outStream !== undefined
                ? message.outStream
                : new Uint8Array(0)));
        message.errStream !== undefined &&
            (obj.errStream = base64FromBytes(message.errStream !== undefined
                ? message.errStream
                : new Uint8Array(0)));
        return obj;
    },
    create(base) {
        return exports.BurnBootloaderResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseBurnBootloaderResponse();
        message.outStream = (_a = object.outStream) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.errStream = (_b = object.errStream) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        return message;
    },
};
function createBaseListProgrammersAvailableForUploadRequest() {
    return { instance: undefined, fqbn: '' };
}
exports.ListProgrammersAvailableForUploadRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.fqbn !== '') {
            writer.uint32(18).string(message.fqbn);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListProgrammersAvailableForUploadRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fqbn = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            fqbn: isSet(object.fqbn) ? String(object.fqbn) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.fqbn !== undefined && (obj.fqbn = message.fqbn);
        return obj;
    },
    create(base) {
        return exports.ListProgrammersAvailableForUploadRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseListProgrammersAvailableForUploadRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.fqbn = (_a = object.fqbn) !== null && _a !== void 0 ? _a : '';
        return message;
    },
};
function createBaseListProgrammersAvailableForUploadResponse() {
    return { programmers: [] };
}
exports.ListProgrammersAvailableForUploadResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.programmers) {
            common_1.Programmer.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListProgrammersAvailableForUploadResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.programmers.push(common_1.Programmer.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            programmers: Array.isArray(object === null || object === void 0 ? void 0 : object.programmers)
                ? object.programmers.map((e) => common_1.Programmer.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.programmers) {
            obj.programmers = message.programmers.map((e) => e ? common_1.Programmer.toJSON(e) : undefined);
        }
        else {
            obj.programmers = [];
        }
        return obj;
    },
    create(base) {
        return exports.ListProgrammersAvailableForUploadResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseListProgrammersAvailableForUploadResponse();
        message.programmers =
            ((_a = object.programmers) === null || _a === void 0 ? void 0 : _a.map((e) => common_1.Programmer.fromPartial(e))) || [];
        return message;
    },
};
function createBaseSupportedUserFieldsRequest() {
    return { instance: undefined, fqbn: '', protocol: '' };
}
exports.SupportedUserFieldsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.instance !== undefined) {
            common_1.Instance.encode(message.instance, writer.uint32(10).fork()).ldelim();
        }
        if (message.fqbn !== '') {
            writer.uint32(18).string(message.fqbn);
        }
        if (message.protocol !== '') {
            writer.uint32(26).string(message.protocol);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSupportedUserFieldsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.instance = common_1.Instance.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fqbn = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.protocol = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            instance: isSet(object.instance)
                ? common_1.Instance.fromJSON(object.instance)
                : undefined,
            fqbn: isSet(object.fqbn) ? String(object.fqbn) : '',
            protocol: isSet(object.protocol) ? String(object.protocol) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.instance !== undefined &&
            (obj.instance = message.instance
                ? common_1.Instance.toJSON(message.instance)
                : undefined);
        message.fqbn !== undefined && (obj.fqbn = message.fqbn);
        message.protocol !== undefined && (obj.protocol = message.protocol);
        return obj;
    },
    create(base) {
        return exports.SupportedUserFieldsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSupportedUserFieldsRequest();
        message.instance =
            object.instance !== undefined && object.instance !== null
                ? common_1.Instance.fromPartial(object.instance)
                : undefined;
        message.fqbn = (_a = object.fqbn) !== null && _a !== void 0 ? _a : '';
        message.protocol = (_b = object.protocol) !== null && _b !== void 0 ? _b : '';
        return message;
    },
};
function createBaseUserField() {
    return { toolId: '', name: '', label: '', secret: false };
}
exports.UserField = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.toolId !== '') {
            writer.uint32(10).string(message.toolId);
        }
        if (message.name !== '') {
            writer.uint32(18).string(message.name);
        }
        if (message.label !== '') {
            writer.uint32(26).string(message.label);
        }
        if (message.secret === true) {
            writer.uint32(32).bool(message.secret);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserField();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.toolId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.label = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.secret = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            toolId: isSet(object.toolId) ? String(object.toolId) : '',
            name: isSet(object.name) ? String(object.name) : '',
            label: isSet(object.label) ? String(object.label) : '',
            secret: isSet(object.secret) ? Boolean(object.secret) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.toolId !== undefined && (obj.toolId = message.toolId);
        message.name !== undefined && (obj.name = message.name);
        message.label !== undefined && (obj.label = message.label);
        message.secret !== undefined && (obj.secret = message.secret);
        return obj;
    },
    create(base) {
        return exports.UserField.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseUserField();
        message.toolId = (_a = object.toolId) !== null && _a !== void 0 ? _a : '';
        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : '';
        message.label = (_c = object.label) !== null && _c !== void 0 ? _c : '';
        message.secret = (_d = object.secret) !== null && _d !== void 0 ? _d : false;
        return message;
    },
};
function createBaseSupportedUserFieldsResponse() {
    return { userFields: [] };
}
exports.SupportedUserFieldsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.userFields) {
            exports.UserField.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSupportedUserFieldsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.userFields.push(exports.UserField.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            userFields: Array.isArray(object === null || object === void 0 ? void 0 : object.userFields)
                ? object.userFields.map((e) => exports.UserField.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.userFields) {
            obj.userFields = message.userFields.map((e) => e ? exports.UserField.toJSON(e) : undefined);
        }
        else {
            obj.userFields = [];
        }
        return obj;
    },
    create(base) {
        return exports.SupportedUserFieldsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseSupportedUserFieldsResponse();
        message.userFields =
            ((_a = object.userFields) === null || _a === void 0 ? void 0 : _a.map((e) => exports.UserField.fromPartial(e))) || [];
        return message;
    },
};
const tsProtoGlobalThis = (() => {
    if (typeof globalThis !== 'undefined') {
        return globalThis;
    }
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw 'Unable to locate global object';
})();
function bytesFromBase64(b64) {
    if (tsProtoGlobalThis.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, 'base64'));
    }
    else {
        const bin = tsProtoGlobalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (tsProtoGlobalThis.Buffer) {
        return tsProtoGlobalThis.Buffer.from(arr).toString('base64');
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis.btoa(bin.join(''));
    }
}
function isObject(value) {
    return typeof value === 'object' && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
