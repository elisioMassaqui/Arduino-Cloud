import _m0 from 'protobufjs/minimal';
import { DownloadProgress, Instance, TaskProgress } from './common';
export declare enum LibraryInstallLocation {
    /**
     * LIBRARY_INSTALL_LOCATION_USER - In the `libraries` subdirectory of the user directory (sketchbook). This is
     * the default if not specified.
     */
    LIBRARY_INSTALL_LOCATION_USER = 0,
    /** LIBRARY_INSTALL_LOCATION_BUILTIN - In the configured 'builtin.libraries' directory. */
    LIBRARY_INSTALL_LOCATION_BUILTIN = 1,
    UNRECOGNIZED = -1
}
export declare function libraryInstallLocationFromJSON(object: any): LibraryInstallLocation;
export declare function libraryInstallLocationToJSON(object: LibraryInstallLocation): string;
export declare enum LibrarySearchStatus {
    /** LIBRARY_SEARCH_STATUS_FAILED - No search results were found. */
    LIBRARY_SEARCH_STATUS_FAILED = 0,
    /** LIBRARY_SEARCH_STATUS_SUCCESS - Search results were found. */
    LIBRARY_SEARCH_STATUS_SUCCESS = 1,
    UNRECOGNIZED = -1
}
export declare function librarySearchStatusFromJSON(object: any): LibrarySearchStatus;
export declare function librarySearchStatusToJSON(object: LibrarySearchStatus): string;
export declare enum LibraryLayout {
    /** LIBRARY_LAYOUT_FLAT - Library is in the 1.0 Arduino library format. */
    LIBRARY_LAYOUT_FLAT = 0,
    /** LIBRARY_LAYOUT_RECURSIVE - Library is in the 1.5 Arduino library format. */
    LIBRARY_LAYOUT_RECURSIVE = 1,
    UNRECOGNIZED = -1
}
export declare function libraryLayoutFromJSON(object: any): LibraryLayout;
export declare function libraryLayoutToJSON(object: LibraryLayout): string;
export declare enum LibraryLocation {
    /** LIBRARY_LOCATION_BUILTIN - In the configured 'builtin.libraries' directory. */
    LIBRARY_LOCATION_BUILTIN = 0,
    /** LIBRARY_LOCATION_USER - In the `libraries` subdirectory of the user directory (sketchbook). */
    LIBRARY_LOCATION_USER = 1,
    /** LIBRARY_LOCATION_PLATFORM_BUILTIN - In the `libraries` subdirectory of a platform. */
    LIBRARY_LOCATION_PLATFORM_BUILTIN = 2,
    /**
     * LIBRARY_LOCATION_REFERENCED_PLATFORM_BUILTIN - When `LibraryLocation` is used in a context where a board is specified,
     * this indicates the library is in the `libraries` subdirectory of a
     * platform referenced by the board's platform.
     */
    LIBRARY_LOCATION_REFERENCED_PLATFORM_BUILTIN = 3,
    /** LIBRARY_LOCATION_UNMANAGED - Outside the `libraries` folders managed by the CLI. */
    LIBRARY_LOCATION_UNMANAGED = 4,
    UNRECOGNIZED = -1
}
export declare function libraryLocationFromJSON(object: any): LibraryLocation;
export declare function libraryLocationToJSON(object: LibraryLocation): string;
export interface LibraryDownloadRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /** Name of the library. */
    name: string;
    /** The version of the library to download. */
    version: string;
}
export interface LibraryDownloadResponse {
    /** Progress of the library download. */
    progress: DownloadProgress | undefined;
}
export interface LibraryInstallRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /** Name of the library. */
    name: string;
    /** The version of the library to install. */
    version: string;
    /**
     * Set to true to skip installation of specified library's dependencies,
     * defaults to false.
     */
    noDeps: boolean;
    /**
     * Set to true to skip installation if a different version of the library or
     * one of its dependencies is already installed, defaults to false.
     */
    noOverwrite: boolean;
    /** Install the library and dependencies in the specified location */
    installLocation: LibraryInstallLocation;
}
export interface LibraryInstallResponse {
    /** Progress of the library download. */
    progress: DownloadProgress | undefined;
    /** Description of the current stage of the installation. */
    taskProgress: TaskProgress | undefined;
}
export interface LibraryUpgradeRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /** Name of the library. */
    name: string;
    /**
     * Set to true to skip installation of specified library's dependencies,
     * defaults to false.
     */
    noDeps: boolean;
}
export interface LibraryUpgradeResponse {
    /** Progress of the library download. */
    progress: DownloadProgress | undefined;
    /** Description of the current stage of the installation. */
    taskProgress: TaskProgress | undefined;
}
export interface LibraryUninstallRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /** Name of the library. */
    name: string;
    /** The version of the library to uninstall. */
    version: string;
}
export interface LibraryUninstallResponse {
    /** Description of the current stage of the uninstallation. */
    taskProgress: TaskProgress | undefined;
}
export interface LibraryUpgradeAllRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
}
export interface LibraryUpgradeAllResponse {
    /** Progress of the downloads of files needed for the upgrades. */
    progress: DownloadProgress | undefined;
    /** Description of the current stage of the upgrade. */
    taskProgress: TaskProgress | undefined;
}
export interface LibraryResolveDependenciesRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /** Name of the library. */
    name: string;
    /**
     * The version of the library to check dependencies of. If no version is
     * specified, dependencies of the newest version will be listed.
     */
    version: string;
}
export interface LibraryResolveDependenciesResponse {
    /** Dependencies of the library. */
    dependencies: LibraryDependencyStatus[];
}
export interface LibraryDependencyStatus {
    /** The name of the library dependency. */
    name: string;
    /** The required version of the library dependency. */
    versionRequired: string;
    /** Version of the library dependency currently installed. */
    versionInstalled: string;
}
export interface LibrarySearchRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /**
     * Deprecated. Use search_args instead.
     *
     * @deprecated
     */
    query: string;
    /**
     * Set to true to not populate the releases field in the response (may save a
     * lot of bandwidth/CPU).
     */
    omitReleasesDetails: boolean;
    /** Keywords for the search. */
    searchArgs: string;
}
export interface LibrarySearchResponse {
    /** The results of the search. */
    libraries: SearchedLibrary[];
    /** Whether the search yielded results. */
    status: LibrarySearchStatus;
}
export interface SearchedLibrary {
    /** Library name. */
    name: string;
    /**
     * The index data for the available versions of the library. The key of the
     * map is the library version.
     */
    releases: {
        [key: string]: LibraryRelease;
    };
    /** The index data for the latest version of the library. */
    latest: LibraryRelease | undefined;
    /** The available versions of this library. */
    availableVersions: string[];
}
export interface SearchedLibrary_ReleasesEntry {
    key: string;
    value: LibraryRelease | undefined;
}
export interface LibraryRelease {
    /** Value of the `author` field in library.properties. */
    author: string;
    /** Value of the `version` field in library.properties. */
    version: string;
    /** Value of the `maintainer` field in library.properties. */
    maintainer: string;
    /** Value of the `sentence` field in library.properties. */
    sentence: string;
    /** Value of the `paragraph` field in library.properties. */
    paragraph: string;
    /** Value of the `url` field in library.properties. */
    website: string;
    /** Value of the `category` field in library.properties. */
    category: string;
    /** Value of the `architectures` field in library.properties. */
    architectures: string[];
    /**
     * The type categories of the library, as defined in the libraries index.
     * Possible values: `Arduino`, `Partner`, `Recommended`, `Contributed`,
     * `Retired`.
     */
    types: string[];
    /** Information about the library archive file. */
    resources: DownloadResource | undefined;
    /** Value of the `license` field in library.properties. */
    license: string;
    /** Value of the `includes` field in library.properties. */
    providesIncludes: string[];
    /**
     * The names of the library's dependencies, as defined by the 'depends'
     * field of library.properties.
     */
    dependencies: LibraryDependency[];
}
export interface LibraryDependency {
    /** Library name of the dependency. */
    name: string;
    /** Version constraint of the dependency. */
    versionConstraint: string;
}
export interface DownloadResource {
    /** Download URL of the library archive. */
    url: string;
    /** Filename of the library archive. */
    archiveFilename: string;
    /** Checksum of the library archive. */
    checksum: string;
    /** File size of the library archive. */
    size: number;
    /**
     * The directory under the staging subdirectory of the data directory the
     * library archive file will be downloaded to.
     */
    cachePath: string;
}
export interface LibraryListRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /**
     * Whether to include built-in libraries (from platforms and the Arduino
     * IDE) in the listing.
     */
    all: boolean;
    /**
     * Whether to list only libraries for which there is a newer version than
     * the installed version available in the libraries index.
     */
    updatable: boolean;
    /** If set filters out the libraries not matching name */
    name: string;
    /**
     * By setting this field all duplicate libraries are filtered out leaving
     * only the libraries that will be used to compile for the specified board
     * FQBN.
     */
    fqbn: string;
}
export interface LibraryListResponse {
    /** List of installed libraries. */
    installedLibraries: InstalledLibrary[];
}
export interface InstalledLibrary {
    /** Information about the library. */
    library: Library | undefined;
    /**
     * When the `updatable` field of the `LibraryList` request is set to `true`,
     * this will contain information on the latest version of the library in the
     * libraries index.
     */
    release: LibraryRelease | undefined;
}
export interface Library {
    /** Library name (value of `name` field in library.properties). */
    name: string;
    /** Value of the `author` field in library.properties. */
    author: string;
    /** Value of the `maintainer` field in library.properties. */
    maintainer: string;
    /** Value of the `sentence` field in library.properties. */
    sentence: string;
    /** Value of the `paragraph` field in library.properties. */
    paragraph: string;
    /** Value of the `url` field in library.properties. */
    website: string;
    /** Value of the `category` field in library.properties. */
    category: string;
    /** Value of the `architectures` field in library.properties. */
    architectures: string[];
    /**
     * The type categories of the library. Possible values: `Arduino`,
     * `Partner`, `Recommended`, `Contributed`, `Retired`.
     */
    types: string[];
    /** The path of the library directory. */
    installDir: string;
    /** The location of the library's source files. */
    sourceDir: string;
    /** The location of the library's `utility` directory. */
    utilityDir: string;
    /**
     * If `location` is `platform_builtin` or `referenced_platform_builtin`, the
     * identifying string for the platform containing the library
     * (e.g., `arduino:avr@1.8.2`).
     */
    containerPlatform: string;
    /** Value of the `dot_a_linkage` field in library.properties. */
    dotALinkage: boolean;
    /** Value of the `precompiled` field in library.properties. */
    precompiled: boolean;
    /** Value of the `ldflags` field in library.properties. */
    ldFlags: string;
    /** A library.properties file is not present in the library's root directory. */
    isLegacy: boolean;
    /** Value of the `version` field in library.properties. */
    version: string;
    /** Value of the `license` field in library.properties. */
    license: string;
    /**
     * The data from the library's library.properties file, including unused
     * fields.
     */
    properties: {
        [key: string]: string;
    };
    /** The location type of the library installation. */
    location: LibraryLocation;
    /** The library format type. */
    layout: LibraryLayout;
    /** The example sketches provided by the library */
    examples: string[];
    /**
     * Value of the `includes` field in library.properties or, if missing, the
     * list of include files available on the library source root directory.
     */
    providesIncludes: string[];
    /** Map of FQBNs that specifies if library is compatible with this library */
    compatibleWith: {
        [key: string]: boolean;
    };
    /**
     * This value is set to true if the library is in development and should not
     * be treated as read-only. This status is determined by the presence of a
     * `.development` file in the library root directory.
     */
    inDevelopment: boolean;
}
export interface Library_PropertiesEntry {
    key: string;
    value: string;
}
export interface Library_CompatibleWithEntry {
    key: string;
    value: boolean;
}
export interface ZipLibraryInstallRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /** Path to the archived library */
    path: string;
    /**
     * Set to true to overwrite an already installed library with the same name.
     * Defaults to false.
     */
    overwrite: boolean;
}
export interface ZipLibraryInstallResponse {
    /** Description of the current stage of the installation. */
    taskProgress: TaskProgress | undefined;
}
export interface GitLibraryInstallRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /** URL to the repository containing the library */
    url: string;
    /**
     * Set to true to overwrite an already installed library with the same name.
     * Defaults to false.
     */
    overwrite: boolean;
}
export interface GitLibraryInstallResponse {
    /** Description of the current stage of the installation. */
    taskProgress: TaskProgress | undefined;
}
export declare const LibraryDownloadRequest: {
    encode(message: LibraryDownloadRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryDownloadRequest;
    fromJSON(object: any): LibraryDownloadRequest;
    toJSON(message: LibraryDownloadRequest): unknown;
    create(base?: DeepPartial<LibraryDownloadRequest>): LibraryDownloadRequest;
    fromPartial(object: DeepPartial<LibraryDownloadRequest>): LibraryDownloadRequest;
};
export declare const LibraryDownloadResponse: {
    encode(message: LibraryDownloadResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryDownloadResponse;
    fromJSON(object: any): LibraryDownloadResponse;
    toJSON(message: LibraryDownloadResponse): unknown;
    create(base?: DeepPartial<LibraryDownloadResponse>): LibraryDownloadResponse;
    fromPartial(object: DeepPartial<LibraryDownloadResponse>): LibraryDownloadResponse;
};
export declare const LibraryInstallRequest: {
    encode(message: LibraryInstallRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryInstallRequest;
    fromJSON(object: any): LibraryInstallRequest;
    toJSON(message: LibraryInstallRequest): unknown;
    create(base?: DeepPartial<LibraryInstallRequest>): LibraryInstallRequest;
    fromPartial(object: DeepPartial<LibraryInstallRequest>): LibraryInstallRequest;
};
export declare const LibraryInstallResponse: {
    encode(message: LibraryInstallResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryInstallResponse;
    fromJSON(object: any): LibraryInstallResponse;
    toJSON(message: LibraryInstallResponse): unknown;
    create(base?: DeepPartial<LibraryInstallResponse>): LibraryInstallResponse;
    fromPartial(object: DeepPartial<LibraryInstallResponse>): LibraryInstallResponse;
};
export declare const LibraryUpgradeRequest: {
    encode(message: LibraryUpgradeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryUpgradeRequest;
    fromJSON(object: any): LibraryUpgradeRequest;
    toJSON(message: LibraryUpgradeRequest): unknown;
    create(base?: DeepPartial<LibraryUpgradeRequest>): LibraryUpgradeRequest;
    fromPartial(object: DeepPartial<LibraryUpgradeRequest>): LibraryUpgradeRequest;
};
export declare const LibraryUpgradeResponse: {
    encode(message: LibraryUpgradeResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryUpgradeResponse;
    fromJSON(object: any): LibraryUpgradeResponse;
    toJSON(message: LibraryUpgradeResponse): unknown;
    create(base?: DeepPartial<LibraryUpgradeResponse>): LibraryUpgradeResponse;
    fromPartial(object: DeepPartial<LibraryUpgradeResponse>): LibraryUpgradeResponse;
};
export declare const LibraryUninstallRequest: {
    encode(message: LibraryUninstallRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryUninstallRequest;
    fromJSON(object: any): LibraryUninstallRequest;
    toJSON(message: LibraryUninstallRequest): unknown;
    create(base?: DeepPartial<LibraryUninstallRequest>): LibraryUninstallRequest;
    fromPartial(object: DeepPartial<LibraryUninstallRequest>): LibraryUninstallRequest;
};
export declare const LibraryUninstallResponse: {
    encode(message: LibraryUninstallResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryUninstallResponse;
    fromJSON(object: any): LibraryUninstallResponse;
    toJSON(message: LibraryUninstallResponse): unknown;
    create(base?: DeepPartial<LibraryUninstallResponse>): LibraryUninstallResponse;
    fromPartial(object: DeepPartial<LibraryUninstallResponse>): LibraryUninstallResponse;
};
export declare const LibraryUpgradeAllRequest: {
    encode(message: LibraryUpgradeAllRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryUpgradeAllRequest;
    fromJSON(object: any): LibraryUpgradeAllRequest;
    toJSON(message: LibraryUpgradeAllRequest): unknown;
    create(base?: DeepPartial<LibraryUpgradeAllRequest>): LibraryUpgradeAllRequest;
    fromPartial(object: DeepPartial<LibraryUpgradeAllRequest>): LibraryUpgradeAllRequest;
};
export declare const LibraryUpgradeAllResponse: {
    encode(message: LibraryUpgradeAllResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryUpgradeAllResponse;
    fromJSON(object: any): LibraryUpgradeAllResponse;
    toJSON(message: LibraryUpgradeAllResponse): unknown;
    create(base?: DeepPartial<LibraryUpgradeAllResponse>): LibraryUpgradeAllResponse;
    fromPartial(object: DeepPartial<LibraryUpgradeAllResponse>): LibraryUpgradeAllResponse;
};
export declare const LibraryResolveDependenciesRequest: {
    encode(message: LibraryResolveDependenciesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryResolveDependenciesRequest;
    fromJSON(object: any): LibraryResolveDependenciesRequest;
    toJSON(message: LibraryResolveDependenciesRequest): unknown;
    create(base?: DeepPartial<LibraryResolveDependenciesRequest>): LibraryResolveDependenciesRequest;
    fromPartial(object: DeepPartial<LibraryResolveDependenciesRequest>): LibraryResolveDependenciesRequest;
};
export declare const LibraryResolveDependenciesResponse: {
    encode(message: LibraryResolveDependenciesResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryResolveDependenciesResponse;
    fromJSON(object: any): LibraryResolveDependenciesResponse;
    toJSON(message: LibraryResolveDependenciesResponse): unknown;
    create(base?: DeepPartial<LibraryResolveDependenciesResponse>): LibraryResolveDependenciesResponse;
    fromPartial(object: DeepPartial<LibraryResolveDependenciesResponse>): LibraryResolveDependenciesResponse;
};
export declare const LibraryDependencyStatus: {
    encode(message: LibraryDependencyStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryDependencyStatus;
    fromJSON(object: any): LibraryDependencyStatus;
    toJSON(message: LibraryDependencyStatus): unknown;
    create(base?: DeepPartial<LibraryDependencyStatus>): LibraryDependencyStatus;
    fromPartial(object: DeepPartial<LibraryDependencyStatus>): LibraryDependencyStatus;
};
export declare const LibrarySearchRequest: {
    encode(message: LibrarySearchRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibrarySearchRequest;
    fromJSON(object: any): LibrarySearchRequest;
    toJSON(message: LibrarySearchRequest): unknown;
    create(base?: DeepPartial<LibrarySearchRequest>): LibrarySearchRequest;
    fromPartial(object: DeepPartial<LibrarySearchRequest>): LibrarySearchRequest;
};
export declare const LibrarySearchResponse: {
    encode(message: LibrarySearchResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibrarySearchResponse;
    fromJSON(object: any): LibrarySearchResponse;
    toJSON(message: LibrarySearchResponse): unknown;
    create(base?: DeepPartial<LibrarySearchResponse>): LibrarySearchResponse;
    fromPartial(object: DeepPartial<LibrarySearchResponse>): LibrarySearchResponse;
};
export declare const SearchedLibrary: {
    encode(message: SearchedLibrary, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SearchedLibrary;
    fromJSON(object: any): SearchedLibrary;
    toJSON(message: SearchedLibrary): unknown;
    create(base?: DeepPartial<SearchedLibrary>): SearchedLibrary;
    fromPartial(object: DeepPartial<SearchedLibrary>): SearchedLibrary;
};
export declare const SearchedLibrary_ReleasesEntry: {
    encode(message: SearchedLibrary_ReleasesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SearchedLibrary_ReleasesEntry;
    fromJSON(object: any): SearchedLibrary_ReleasesEntry;
    toJSON(message: SearchedLibrary_ReleasesEntry): unknown;
    create(base?: DeepPartial<SearchedLibrary_ReleasesEntry>): SearchedLibrary_ReleasesEntry;
    fromPartial(object: DeepPartial<SearchedLibrary_ReleasesEntry>): SearchedLibrary_ReleasesEntry;
};
export declare const LibraryRelease: {
    encode(message: LibraryRelease, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryRelease;
    fromJSON(object: any): LibraryRelease;
    toJSON(message: LibraryRelease): unknown;
    create(base?: DeepPartial<LibraryRelease>): LibraryRelease;
    fromPartial(object: DeepPartial<LibraryRelease>): LibraryRelease;
};
export declare const LibraryDependency: {
    encode(message: LibraryDependency, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryDependency;
    fromJSON(object: any): LibraryDependency;
    toJSON(message: LibraryDependency): unknown;
    create(base?: DeepPartial<LibraryDependency>): LibraryDependency;
    fromPartial(object: DeepPartial<LibraryDependency>): LibraryDependency;
};
export declare const DownloadResource: {
    encode(message: DownloadResource, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DownloadResource;
    fromJSON(object: any): DownloadResource;
    toJSON(message: DownloadResource): unknown;
    create(base?: DeepPartial<DownloadResource>): DownloadResource;
    fromPartial(object: DeepPartial<DownloadResource>): DownloadResource;
};
export declare const LibraryListRequest: {
    encode(message: LibraryListRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryListRequest;
    fromJSON(object: any): LibraryListRequest;
    toJSON(message: LibraryListRequest): unknown;
    create(base?: DeepPartial<LibraryListRequest>): LibraryListRequest;
    fromPartial(object: DeepPartial<LibraryListRequest>): LibraryListRequest;
};
export declare const LibraryListResponse: {
    encode(message: LibraryListResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LibraryListResponse;
    fromJSON(object: any): LibraryListResponse;
    toJSON(message: LibraryListResponse): unknown;
    create(base?: DeepPartial<LibraryListResponse>): LibraryListResponse;
    fromPartial(object: DeepPartial<LibraryListResponse>): LibraryListResponse;
};
export declare const InstalledLibrary: {
    encode(message: InstalledLibrary, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InstalledLibrary;
    fromJSON(object: any): InstalledLibrary;
    toJSON(message: InstalledLibrary): unknown;
    create(base?: DeepPartial<InstalledLibrary>): InstalledLibrary;
    fromPartial(object: DeepPartial<InstalledLibrary>): InstalledLibrary;
};
export declare const Library: {
    encode(message: Library, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Library;
    fromJSON(object: any): Library;
    toJSON(message: Library): unknown;
    create(base?: DeepPartial<Library>): Library;
    fromPartial(object: DeepPartial<Library>): Library;
};
export declare const Library_PropertiesEntry: {
    encode(message: Library_PropertiesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Library_PropertiesEntry;
    fromJSON(object: any): Library_PropertiesEntry;
    toJSON(message: Library_PropertiesEntry): unknown;
    create(base?: DeepPartial<Library_PropertiesEntry>): Library_PropertiesEntry;
    fromPartial(object: DeepPartial<Library_PropertiesEntry>): Library_PropertiesEntry;
};
export declare const Library_CompatibleWithEntry: {
    encode(message: Library_CompatibleWithEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Library_CompatibleWithEntry;
    fromJSON(object: any): Library_CompatibleWithEntry;
    toJSON(message: Library_CompatibleWithEntry): unknown;
    create(base?: DeepPartial<Library_CompatibleWithEntry>): Library_CompatibleWithEntry;
    fromPartial(object: DeepPartial<Library_CompatibleWithEntry>): Library_CompatibleWithEntry;
};
export declare const ZipLibraryInstallRequest: {
    encode(message: ZipLibraryInstallRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZipLibraryInstallRequest;
    fromJSON(object: any): ZipLibraryInstallRequest;
    toJSON(message: ZipLibraryInstallRequest): unknown;
    create(base?: DeepPartial<ZipLibraryInstallRequest>): ZipLibraryInstallRequest;
    fromPartial(object: DeepPartial<ZipLibraryInstallRequest>): ZipLibraryInstallRequest;
};
export declare const ZipLibraryInstallResponse: {
    encode(message: ZipLibraryInstallResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ZipLibraryInstallResponse;
    fromJSON(object: any): ZipLibraryInstallResponse;
    toJSON(message: ZipLibraryInstallResponse): unknown;
    create(base?: DeepPartial<ZipLibraryInstallResponse>): ZipLibraryInstallResponse;
    fromPartial(object: DeepPartial<ZipLibraryInstallResponse>): ZipLibraryInstallResponse;
};
export declare const GitLibraryInstallRequest: {
    encode(message: GitLibraryInstallRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GitLibraryInstallRequest;
    fromJSON(object: any): GitLibraryInstallRequest;
    toJSON(message: GitLibraryInstallRequest): unknown;
    create(base?: DeepPartial<GitLibraryInstallRequest>): GitLibraryInstallRequest;
    fromPartial(object: DeepPartial<GitLibraryInstallRequest>): GitLibraryInstallRequest;
};
export declare const GitLibraryInstallResponse: {
    encode(message: GitLibraryInstallResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GitLibraryInstallResponse;
    fromJSON(object: any): GitLibraryInstallResponse;
    toJSON(message: GitLibraryInstallResponse): unknown;
    create(base?: DeepPartial<GitLibraryInstallResponse>): GitLibraryInstallResponse;
    fromPartial(object: DeepPartial<GitLibraryInstallResponse>): GitLibraryInstallResponse;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, '$case'>]?: DeepPartial<T[K]>;
} & {
    $case: T['$case'];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=lib.d.ts.map