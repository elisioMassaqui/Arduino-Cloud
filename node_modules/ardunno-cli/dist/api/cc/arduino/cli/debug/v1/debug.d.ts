import type { CallContext, CallOptions } from 'nice-grpc-common';
import _m0 from 'protobufjs/minimal';
import { Instance } from '../../commands/v1/common';
import { Port } from '../../commands/v1/port';
/**
 * The top-level message sent by the client for the `Debug` method.
 * Multiple `DebugReq` messages can be sent but the first message
 * must contain a `DebugConfigReq` message to initialize the debug session.
 * All subsequent messages must contain bytes to be sent to the debug session
 * and must not contain a `DebugReq` message.
 */
export interface DebugRequest {
    /**
     * Provides information to the debug that specifies which is the target.
     * The first `StreamingOpenReq` message must contain a `DebugReq`
     * message.
     */
    debugRequest: DebugConfigRequest | undefined;
    /** The data to be sent to the target being monitored. */
    data: Uint8Array;
    /** Set this to true to send and Interrupt signal to the debugger process */
    sendInterrupt: boolean;
}
export interface DebugConfigRequest {
    /** Arduino Core Service instance from the `Init` response. */
    instance: Instance | undefined;
    /**
     * Fully qualified board name of the board in use
     * (e.g., `arduino:samd:mkr1000`). If this is omitted, the FQBN attached to
     * the sketch will be used.
     */
    fqbn: string;
    /**
     * Path to the sketch that is running on the board. The compiled executable
     * is expected to be located under this path.
     */
    sketchPath: string;
    /** Port of the debugger (optional). */
    port: Port | undefined;
    /** Which GDB command interpreter to use. */
    interpreter: string;
    /**
     * Directory containing the compiled executable. If `import_dir` is not
     * specified, the executable is assumed to be in
     * `{sketch_path}/build/{fqbn}/`.
     */
    importDir: string;
    /** The programmer to use for debugging. */
    programmer: string;
}
/**  */
export interface DebugResponse {
    /** Incoming data from the debugger tool. */
    data: Uint8Array;
    /** Incoming error output from the debugger tool. */
    error: string;
}
export interface GetDebugConfigResponse {
    /** The executable binary to debug */
    executable: string;
    /** The toolchain type used for the build (for example "gcc") */
    toolchain: string;
    /** The toolchain directory */
    toolchainPath: string;
    /** The toolchain architecture prefix (for example "arm-none-eabi-") */
    toolchainPrefix: string;
    /**
     * The GDB server type used to connect to the programmer/board (for example
     * "openocd")
     */
    server: string;
    /** The GDB server directory */
    serverPath: string;
    /** Extra configuration parameters wrt toolchain */
    toolchainConfiguration: {
        [key: string]: string;
    };
    /** Extra configuration parameters wrt GDB server */
    serverConfiguration: {
        [key: string]: string;
    };
}
export interface GetDebugConfigResponse_ToolchainConfigurationEntry {
    key: string;
    value: string;
}
export interface GetDebugConfigResponse_ServerConfigurationEntry {
    key: string;
    value: string;
}
export declare const DebugRequest: {
    encode(message: DebugRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DebugRequest;
    fromJSON(object: any): DebugRequest;
    toJSON(message: DebugRequest): unknown;
    create(base?: DeepPartial<DebugRequest>): DebugRequest;
    fromPartial(object: DeepPartial<DebugRequest>): DebugRequest;
};
export declare const DebugConfigRequest: {
    encode(message: DebugConfigRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DebugConfigRequest;
    fromJSON(object: any): DebugConfigRequest;
    toJSON(message: DebugConfigRequest): unknown;
    create(base?: DeepPartial<DebugConfigRequest>): DebugConfigRequest;
    fromPartial(object: DeepPartial<DebugConfigRequest>): DebugConfigRequest;
};
export declare const DebugResponse: {
    encode(message: DebugResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DebugResponse;
    fromJSON(object: any): DebugResponse;
    toJSON(message: DebugResponse): unknown;
    create(base?: DeepPartial<DebugResponse>): DebugResponse;
    fromPartial(object: DeepPartial<DebugResponse>): DebugResponse;
};
export declare const GetDebugConfigResponse: {
    encode(message: GetDebugConfigResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetDebugConfigResponse;
    fromJSON(object: any): GetDebugConfigResponse;
    toJSON(message: GetDebugConfigResponse): unknown;
    create(base?: DeepPartial<GetDebugConfigResponse>): GetDebugConfigResponse;
    fromPartial(object: DeepPartial<GetDebugConfigResponse>): GetDebugConfigResponse;
};
export declare const GetDebugConfigResponse_ToolchainConfigurationEntry: {
    encode(message: GetDebugConfigResponse_ToolchainConfigurationEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetDebugConfigResponse_ToolchainConfigurationEntry;
    fromJSON(object: any): GetDebugConfigResponse_ToolchainConfigurationEntry;
    toJSON(message: GetDebugConfigResponse_ToolchainConfigurationEntry): unknown;
    create(base?: DeepPartial<GetDebugConfigResponse_ToolchainConfigurationEntry>): GetDebugConfigResponse_ToolchainConfigurationEntry;
    fromPartial(object: DeepPartial<GetDebugConfigResponse_ToolchainConfigurationEntry>): GetDebugConfigResponse_ToolchainConfigurationEntry;
};
export declare const GetDebugConfigResponse_ServerConfigurationEntry: {
    encode(message: GetDebugConfigResponse_ServerConfigurationEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GetDebugConfigResponse_ServerConfigurationEntry;
    fromJSON(object: any): GetDebugConfigResponse_ServerConfigurationEntry;
    toJSON(message: GetDebugConfigResponse_ServerConfigurationEntry): unknown;
    create(base?: DeepPartial<GetDebugConfigResponse_ServerConfigurationEntry>): GetDebugConfigResponse_ServerConfigurationEntry;
    fromPartial(object: DeepPartial<GetDebugConfigResponse_ServerConfigurationEntry>): GetDebugConfigResponse_ServerConfigurationEntry;
};
/** DebugService abstracts a debug Session usage */
export declare type DebugServiceDefinition = typeof DebugServiceDefinition;
export declare const DebugServiceDefinition: {
    readonly name: "DebugService";
    readonly fullName: "cc.arduino.cli.debug.v1.DebugService";
    readonly methods: {
        /** Start a debug session and communicate with the debugger tool. */
        readonly debug: {
            readonly name: "Debug";
            readonly requestType: {
                encode(message: DebugRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): DebugRequest;
                fromJSON(object: any): DebugRequest;
                toJSON(message: DebugRequest): unknown;
                create(base?: DeepPartial<DebugRequest>): DebugRequest;
                fromPartial(object: DeepPartial<DebugRequest>): DebugRequest;
            };
            readonly requestStream: true;
            readonly responseType: {
                encode(message: DebugResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): DebugResponse;
                fromJSON(object: any): DebugResponse;
                toJSON(message: DebugResponse): unknown;
                create(base?: DeepPartial<DebugResponse>): DebugResponse;
                fromPartial(object: DeepPartial<DebugResponse>): DebugResponse;
            };
            readonly responseStream: true;
            readonly options: {};
        };
        readonly getDebugConfig: {
            readonly name: "GetDebugConfig";
            readonly requestType: {
                encode(message: DebugConfigRequest, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): DebugConfigRequest;
                fromJSON(object: any): DebugConfigRequest;
                toJSON(message: DebugConfigRequest): unknown;
                create(base?: DeepPartial<DebugConfigRequest>): DebugConfigRequest;
                fromPartial(object: DeepPartial<DebugConfigRequest>): DebugConfigRequest;
            };
            readonly requestStream: false;
            readonly responseType: {
                encode(message: GetDebugConfigResponse, writer?: _m0.Writer): _m0.Writer;
                decode(input: _m0.Reader | Uint8Array, length?: number): GetDebugConfigResponse;
                fromJSON(object: any): GetDebugConfigResponse;
                toJSON(message: GetDebugConfigResponse): unknown;
                create(base?: DeepPartial<GetDebugConfigResponse>): GetDebugConfigResponse;
                fromPartial(object: DeepPartial<GetDebugConfigResponse>): GetDebugConfigResponse;
            };
            readonly responseStream: false;
            readonly options: {};
        };
    };
};
export interface DebugServiceImplementation<CallContextExt = {}> {
    /** Start a debug session and communicate with the debugger tool. */
    debug(request: AsyncIterable<DebugRequest>, context: CallContext & CallContextExt): ServerStreamingMethodResult<DeepPartial<DebugResponse>>;
    getDebugConfig(request: DebugConfigRequest, context: CallContext & CallContextExt): Promise<DeepPartial<GetDebugConfigResponse>>;
}
export interface DebugServiceClient<CallOptionsExt = {}> {
    /** Start a debug session and communicate with the debugger tool. */
    debug(request: AsyncIterable<DeepPartial<DebugRequest>>, options?: CallOptions & CallOptionsExt): AsyncIterable<DebugResponse>;
    getDebugConfig(request: DeepPartial<DebugConfigRequest>, options?: CallOptions & CallOptionsExt): Promise<GetDebugConfigResponse>;
}
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, '$case'>]?: DeepPartial<T[K]>;
} & {
    $case: T['$case'];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export declare type ServerStreamingMethodResult<Response> = {
    [Symbol.asyncIterator](): AsyncIterator<Response, void>;
};
export {};
//# sourceMappingURL=debug.d.ts.map